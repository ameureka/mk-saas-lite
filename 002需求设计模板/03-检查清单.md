# 需求文档质量检查清单

在完成需求文档后，使用这个清单进行自查，确保文档质量。

---

## 一、完整性检查（8项）

### ✅ 1. 是否明确了目标用户和使用场景？

**检查要点**：
- [ ] 定义了清晰的用户画像（职业、年龄、技能水平）
- [ ] 描述了具体的使用场景（何时、何地、为何使用）
- [ ] 说明了用户的痛点和期望
- [ ] 区分了主要用户和次要用户

**示例**：
```markdown
✅ 好的描述：
目标用户：职场人士（25-40岁，需要定期制作工作汇报PPT）
使用场景：周五下午需要准备下周一的汇报，时间紧迫，希望快速找到合适模板
痛点：浏览大量模板耗时，关键词搜索不准确

❌ 不好的描述：
目标用户：所有需要PPT的人
```

---

### ✅ 2. 是否定义了可量化的成功指标？

**检查要点**：
- [ ] 每个阶段都有明确的KPI
- [ ] 指标是可量化的（数字、百分比）
- [ ] 指标是可观测的（有监控手段）
- [ ] 指标与业务目标对齐

**示例**：
```markdown
✅ 好的指标：
- DAU > 50（可通过PostHog监控）
- 搜索准确率 > 70%（通过用户反馈和点击率计算）
- 下载转化率 > 30%（搜索到下载的转化）

❌ 不好的指标：
- 用户体验好
- 系统性能优秀
```

---

### ✅ 3. 是否覆盖了7个设计层面？

**检查要点**：
- [ ] 前端层：UI/UX设计、组件库选型
- [ ] 后端层：API设计、数据库schema
- [ ] 交互层：状态管理、API契约
- [ ] 中间件层：异步任务、缓存策略
- [ ] SEO/AIO层：搜索优化、AI索引
- [ ] 部署层：环境变量、CI/CD
- [ ] 安全层：认证授权、数据保护

**快速检查**：
在文档中搜索这些关键词，确保每个层面都有涉及。

---

### ✅ 4. 是否所有功能都有EARS格式的验收标准？

**检查要点**：
- [ ] 每个功能都有5-8条验收标准
- [ ] 使用了EARS关键词（WHEN/THE/SHALL/IF/WHILE）
- [ ] 验收标准是可测试的
- [ ] 验收标准覆盖了正常流程和异常流程

**EARS格式检查**：
```markdown
✅ 符合EARS格式：
WHEN User输入查询词，THE Platform SHALL在3秒内返回前10个结果

❌ 不符合EARS格式：
系统应该支持搜索功能
```

---

### ✅ 5. 是否明确了技术选型和理由？

**检查要点**：
- [ ] 列出了所有关键技术栈
- [ ] 说明了选择理由（而不是"因为流行"）
- [ ] 对比了候选方案
- [ ] 考虑了与mksaas-template的集成

**示例**：
```markdown
✅ 好的技术选型：
向量数据库：选择Pinecone
理由：
1. 免费层5M向量足够MVP
2. 无需运维，开箱即用
3. 有官方Node.js SDK
4. 查询延迟<100ms
对比：Qdrant（免费层1M）、Milvus（需要自建）

❌ 不好的技术选型：
使用Pinecone做向量搜索（没有说明为什么）
```

---

### ✅ 6. 是否设计了数据模型和API？

**检查要点**：
- [ ] 用Drizzle Schema格式定义了所有表结构
- [ ] 说明了表之间的关系（外键）
- [ ] 设计了必要的索引
- [ ] 列出了所有API端点及其Request/Response格式

**示例**：
```typescript
✅ 完整的数据模型：
export const templates = pgTable('templates', {
  id: uuid('id').primaryKey().defaultRandom(),
  title: text('title').notNull(),
  embeddingId: text('embedding_id'),
  createdAt: timestamp('created_at').defaultNow(),
});

// 索引
export const templatesIndex = index('templates_title_idx').on(templates.title);

✅ 完整的API设计：
POST /api/search
Request: { query: string, limit?: number }
Response: { results: Template[], total: number }
Error: { error: string, code: string }
```

---

### ✅ 7. 是否制定了分阶段实施计划？

**检查要点**：
- [ ] 划分了4个阶段（MVP、增强、商业化、规模化）
- [ ] 每个阶段有明确的时间估算（不超过3周）
- [ ] 每个阶段有功能清单和验收标准
- [ ] 每个阶段可独立部署和验证

**示例**：
```markdown
✅ 好的阶段规划：
阶段0：MVP（1-2周）
目标：验证核心假设
功能：基础搜索、详情页、下载
验收：DAU>50，搜索准确率>70%

❌ 不好的阶段规划：
第一阶段：实现所有功能（时间待定）
```

---

### ✅ 8. 是否评估了风险和成本？

**检查要点**：
- [ ] 识别了技术风险和业务风险
- [ ] 每个风险都有应对策略
- [ ] 估算了开发成本和运营成本
- [ ] 计算了ROI和回本周期

**示例**：
```markdown
✅ 完整的风险评估：
风险：向量数据库成本超预算
影响：高（可能导致项目无法持续）
概率：中（用户增长超预期）
应对：初期使用免费层，超出后迁移到自建Milvus

✅ 完整的成本预估：
MVP阶段：开发成本$0 + 运营成本$10/月
增长阶段：运营成本$150/月
预期收入：$300/月
回本周期：1个月
```

---

## 二、可行性检查（5项）

### ✅ 1. 技术选型是否基于团队现有能力？

**检查要点**：
- [ ] 团队熟悉所选技术栈
- [ ] 新技术有学习计划和时间预算
- [ ] 避免了过度复杂的技术方案
- [ ] 考虑了技术的成熟度和社区支持

**自问**：
- 团队是否有人用过这个技术？
- 如果没有，学习成本是多少？
- 是否有充足的文档和社区支持？

---

### ✅ 2. 是否充分复用了mksaas-template的能力？

**检查要点**：
- [ ] 使用了Better Auth而不是自己实现认证
- [ ] 使用了Stripe而不是自己对接支付
- [ ] 使用了Resend而不是自己搭建邮件服务
- [ ] 使用了现有的UI组件库

**快速检查**：
列出所有需要的功能，标注哪些可以复用mksaas-template。

---

### ✅ 3. 第三方服务是否有免费层可用于MVP？

**检查要点**：
- [ ] 所有第三方服务都有免费层或试用期
- [ ] 免费层的限制足够MVP使用
- [ ] 有明确的升级路径
- [ ] 计算了超出免费层后的成本

**示例**：
```markdown
✅ 可行的方案：
- Pinecone：免费层5M向量，足够1万个模板
- Supabase：免费层500MB，足够MVP
- Vercel：免费层足够个人项目

❌ 不可行的方案：
- 自建Milvus：需要服务器成本，MVP阶段不划算
```

---

### ✅ 4. 每个阶段的时间估算是否合理？

**检查要点**：
- [ ] 每个阶段不超过3周
- [ ] 考虑了学习新技术的时间
- [ ] 预留了测试和修复bug的时间
- [ ] 考虑了团队规模和工作时间

**经验法则**：
- 1人全栈：每周可完成2-3个中等功能
- 预留20%时间用于测试和修复
- 预留10%时间用于文档和部署

---

### ✅ 5. 是否识别了高风险项并制定了应对策略？

**检查要点**：
- [ ] 列出了所有高影响或高概率的风险
- [ ] 每个风险都有具体的应对措施
- [ ] 有预算和负责人
- [ ] 有监控和预警机制

**风险优先级**：
```
高影响+高概率 → 必须提前应对
高影响+低概率 → 制定应急预案
低影响+高概率 → 接受风险，持续监控
低影响+低概率 → 忽略
```

---

## 三、可验证性检查（5项）

### ✅ 1. 每个功能是否有明确的验收标准？

**检查要点**：
- [ ] 验收标准是可测试的（不是主观判断）
- [ ] 验收标准是可量化的（有具体数字）
- [ ] 验收标准覆盖了正常和异常流程
- [ ] 验收标准与用户故事对应

**测试方法**：
把验收标准给测试人员，看他们能否据此编写测试用例。

---

### ✅ 2. 每个阶段是否有量化的成功指标？

**检查要点**：
- [ ] 指标是SMART的（具体、可衡量、可达成、相关、有时限）
- [ ] 指标与业务目标对齐
- [ ] 有基线值和目标值
- [ ] 有监控和报告机制

**SMART检查**：
```markdown
✅ SMART指标：
MVP阶段：2周内DAU达到50（具体、可衡量、可达成、相关、有时限）

❌ 非SMART指标：
用户增长良好（不具体、不可衡量、无时限）
```

---

### ✅ 3. 是否定义了监控和观测手段？

**检查要点**：
- [ ] 每个关键功能都有日志记录
- [ ] 有性能监控（响应时间、错误率）
- [ ] 有用户行为追踪（搜索词、点击、转化）
- [ ] 有告警机制（异常自动通知）

**工具检查**：
- [ ] 集成了Vercel Analytics（性能）
- [ ] 集成了PostHog（用户行为）
- [ ] 集成了Sentry（错误监控）
- [ ] 有自定义Dashboard（业务指标）

---

### ✅ 4. 是否可以快速部署预览版本？

**检查要点**：
- [ ] 有明确的部署流程文档
- [ ] 环境变量管理清晰（.env.example）
- [ ] 数据库迁移自动化（Drizzle Kit）
- [ ] 可以一键部署到Vercel

**快速测试**：
新成员能否在30分钟内部署一个预览版本？

---

### ✅ 5. 是否有用户反馈收集机制？

**检查要点**：
- [ ] 有用户反馈入口（表单、邮件、Discord）
- [ ] 有用户测试计划（邀请种子用户）
- [ ] 有反馈分析流程（定期回顾）
- [ ] 有快速迭代机制（1周内响应反馈）

---

## 四、优先级检查（4项）

### ✅ 1. P0功能是否真的是MVP必需的？

**检查要点**：
- [ ] 没有这个功能，产品无法使用
- [ ] 这个功能解决了核心问题
- [ ] 这个功能是用户的刚需
- [ ] 这个功能可以独立验证价值

**判断方法**：
如果去掉这个功能，用户还能完成主流程吗？
- 能 → 不是P0
- 不能 → 是P0

---

### ✅ 2. 是否避免了过度设计？

**检查要点**：
- [ ] 没有提前优化（YAGNI原则）
- [ ] 没有过度抽象（保持简单）
- [ ] 没有追求完美（快速迭代）
- [ ] 只做当前阶段需要的

**常见过度设计**：
- ❌ MVP阶段就做微服务架构
- ❌ MVP阶段就做多语言支持
- ❌ MVP阶段就做复杂的权限系统
- ✅ MVP阶段只做核心功能，后续迭代

---

### ✅ 3. 功能排序是否考虑了价值、风险、依赖？

**检查要点**：
- [ ] 高价值功能优先
- [ ] 高风险功能提前验证
- [ ] 基础设施先于业务功能
- [ ] 依赖关系清晰

**排序矩阵**：
```
高价值+低风险 → 优先做（快速见效）
高价值+高风险 → 提前验证（降低风险）
低价值+低风险 → 后续做（锦上添花）
低价值+高风险 → 不做（性价比低）
```

---

### ✅ 4. 是否有明确的"不做清单"？

**检查要点**：
- [ ] 列出了明确不做的功能
- [ ] 说明了不做的理由
- [ ] 避免了范围蔓延
- [ ] 有拒绝新需求的标准

**示例**：
```markdown
✅ 明确的不做清单：
MVP阶段不做：
- 在线编辑PPT（复杂度高，价值不明确）
- 多语言支持（用户主要是中文）
- 社交功能（不是核心价值）
- 移动端App（Web优先）

理由：专注核心功能，快速验证假设
```

---

## 五、使用建议

### 1. 何时使用这个清单？

**推荐时机**：
- 需求文档初稿完成后
- 提交给团队评审前
- 每个阶段开始前
- 发现问题需要回顾时

### 2. 如何使用这个清单？

**步骤**：
1. 打印或复制这个清单
2. 逐项检查，标记✅或❌
3. 对于❌的项，记录问题和改进方案
4. 优先修复高优先级的问题
5. 重新检查直到所有项都是✅

### 3. 团队协作

**建议**：
- 让不同角色的人检查不同部分
- 产品经理检查：完整性、优先级
- 技术负责人检查：可行性、技术选型
- 测试人员检查：可验证性、验收标准
- 团队一起评审：整体方案

### 4. 持续改进

**建议**：
- 每个项目结束后回顾这个清单
- 根据实际情况增加或删除检查项
- 建立团队的检查清单模板
- 分享最佳实践和经验教训

---

## 六、常见问题

### Q1：所有检查项都必须通过吗？

A：不一定。根据项目阶段和重要性，可以有选择地通过：
- MVP阶段：完整性和可行性是必须的
- 增长阶段：可验证性和优先级更重要
- 规模化阶段：所有检查项都应该通过

### Q2：检查清单太长，如何快速检查？

A：可以分两轮：
- 第一轮：只检查标记为"必须"的项（约15项）
- 第二轮：检查其他项，逐步完善

### Q3：发现问题后如何修复？

A：按优先级修复：
1. 高优先级：影响项目可行性的问题（立即修复）
2. 中优先级：影响项目质量的问题（本周修复）
3. 低优先级：优化性问题（后续迭代）

### Q4：如何避免过度检查？

A：记住检查清单的目的是提高质量，而不是追求完美：
- 不要为了通过检查而过度设计
- 不要在细节上纠结太久
- 保持快速迭代的节奏

---

**下一步**：查看 `04-常见陷阱.md` 学习如何避免常见错误
