# 需求设计方法论

## 一、需求设计核心原则

### 1. 用户驱动原则

需求设计的起点永远是用户，而不是技术。

#### 关键问题
- **谁会用？** 明确目标用户画像（职业、年龄、技能水平）
- **在什么场景下用？** 描述具体使用场景和上下文
- **解决什么问题？** 用户的痛点是什么，为什么现有方案不够好
- **期望什么结果？** 用户使用后想达成什么目标

#### 实践方法
1. **用户故事格式**：作为[角色]，我希望[功能]，以便[价值]
2. **场景化描述**：用具体场景而非抽象功能描述需求
3. **价值优先**：每个功能都要回答"为什么做"而不只是"做什么"
4. **数据验证**：用成功指标（KPI）量化价值，而非主观判断

#### 示例对比

❌ **不好的描述**
```
需求：系统需要支持用户管理功能
```

✅ **好的描述**
```
用户故事：作为管理员，我希望能够查看和管理所有注册用户，
以便及时处理违规账户和提供用户支持

使用场景：
- 每天早上查看新注册用户，识别可疑账户
- 用户投诉时快速查找用户信息
- 定期导出用户数据进行分析

成功指标：
- 处理用户投诉的平均时间从30分钟降低到5分钟
- 可疑账户识别率提升到95%
```

---

### 2. 分层设计原则

需求设计必须覆盖7个层面，确保系统的完整性和可实施性。

#### 2.1 前端层

**关键问题**：
- 用户看到什么？（UI设计）
- 如何交互？（UX流程）
- 响应式设计如何实现？
- 使用什么组件库？

**输出物**：
- 页面结构图
- 交互流程图
- 组件库选型（如shadcn/ui）
- 响应式断点定义

**基于mksaas-template的考虑**：
- 复用现有UI组件（src/components/ui/）
- 遵循现有设计系统（Tailwind配置）
- 考虑国际化（next-intl）
- 考虑主题切换（next-themes）

---

#### 2.2 后端层

**关键问题**：
- 数据如何存储？（数据库设计）
- 业务逻辑在哪？（API设计）
- 如何处理并发？
- 如何保证数据一致性？

**输出物**：
- 数据库Schema（Drizzle格式）
- API端点列表
- 业务逻辑流程图
- 数据验证规则

**基于mksaas-template的考虑**：
- 使用Drizzle ORM（src/db/schema/）
- 遵循现有表命名规范
- 考虑与Better Auth的集成
- 考虑数据迁移策略

---

#### 2.3 交互层

**关键问题**：
- 前后端如何通信？（API契约）
- 状态如何管理？（状态管理方案）
- 如何处理加载和错误状态？
- 如何优化性能？（缓存、预加载）

**输出物**：
- API契约文档（Request/Response格式）
- 状态管理方案（Zustand/React Query）
- 错误处理策略
- 性能优化方案

**基于mksaas-template的考虑**：
- 使用Next.js Server Actions或API Routes
- 使用TanStack Query管理服务端状态
- 使用Zustand管理客户端状态
- 考虑ISR/SSR策略

---

#### 2.4 中间件层

**关键问题**：
- 如何处理异步任务？（队列设计）
- 如何缓存数据？（缓存策略）
- 如何限流？（Rate Limiting）
- 如何处理定时任务？（Cron Jobs）

**输出物**：
- 异步任务队列设计
- 缓存策略文档
- 限流规则
- 定时任务列表

**基于mksaas-template的考虑**：
- MVP阶段：使用Vercel Cron Jobs
- 规模化阶段：考虑Celery + Redis
- 使用Vercel Edge Config做配置管理
- 考虑Vercel KV做简单缓存

---

#### 2.5 SEO/AIO层

**关键问题**：
- 如何被搜索引擎发现？（SEO优化）
- 如何被AI模型索引？（AIO优化）
- 如何提升页面性能？（Core Web Vitals）
- 如何生成结构化数据？（Schema.org）

**输出物**：
- Meta标签策略
- Sitemap生成方案
- 结构化数据设计
- 性能优化清单

**基于mksaas-template的考虑**：
- 使用Fumadocs的SEO功能
- 动态生成Meta标签
- 使用Next.js的Metadata API
- 集成Vercel Analytics

---

#### 2.6 部署层

**关键问题**：
- 如何本地开发？（开发环境）
- 如何管理环境变量？（配置管理）
- 如何部署？（CI/CD流程）
- 如何回滚？（版本管理）

**输出物**：
- 环境变量清单（.env.example）
- 部署流程文档
- CI/CD配置
- 回滚策略

**基于mksaas-template的考虑**：
- 使用Vercel部署（main分支）
- 或使用Cloudflare Workers（cloudflare分支）
- 使用Drizzle Kit管理数据库迁移
- 使用Git分支管理环境

---

#### 2.7 安全层

**关键问题**：
- 如何认证用户？（Authentication）
- 如何授权访问？（Authorization）
- 如何防止攻击？（CSRF、XSS、SQL注入）
- 如何保护敏感数据？（加密、脱敏）

**输出物**：
- 认证授权方案
- 安全检查清单
- 数据加密策略
- 漏洞应对预案

**基于mksaas-template的考虑**：
- 使用Better Auth（已集成）
- 使用Next.js的CSRF保护
- 使用Drizzle的参数化查询防SQL注入
- 使用环境变量保护敏感信息

---

### 3. 阶段化实施原则

将需求分阶段实施，每个阶段可独立交付和验证。

#### 3.1 排序原则

**按价值排序**：
- P0（必需）：没有这个功能，产品无法使用
- P1（重要）：有这个功能，产品体验显著提升
- P2（优化）：锦上添花，可以后续迭代

**按风险排序**：
- 高风险功能优先验证（技术不确定性高的）
- 依赖第三方的功能提前测试
- 复杂度高的功能拆分验证

**按依赖排序**：
- 基础设施先行（认证、数据库、部署）
- 核心功能次之（主要业务逻辑）
- 增强功能最后（优化和扩展）

#### 3.2 阶段划分标准

**每个阶段必须满足**：
- ✅ 时间不超过3周（保持快速迭代）
- ✅ 可独立部署（能上线给用户使用）
- ✅ 可独立验证（有明确的成功指标）
- ✅ 有明确的价值（解决一个完整的用户问题）

**典型的4阶段模型**：

```
阶段0：MVP（1-2周）
目标：验证核心假设
特点：功能最简，快速上线

阶段1：增强（2-3周）
目标：提升核心体验
特点：优化主流程，增加关键功能

阶段2：商业化（2周）
目标：建立收益模式
特点：引入变现机制，提升留存

阶段3：规模化（持续）
目标：支持更大规模
特点：性能优化，成本控制
```

#### 3.3 阶段间的依赖管理

**明确依赖关系**：
- 每个阶段开始前，列出依赖的前置条件
- 每个阶段结束后，明确交付物和接口

**避免阻塞**：
- 使用Mock数据解耦前后端开发
- 使用Feature Flag控制功能上线
- 并行开发独立模块

---

### 4. 可验证性原则

每个需求都必须可验证，避免主观判断和模糊标准。

#### 4.1 EARS格式验收标准

使用EARS（Easy Approach to Requirements Syntax）格式编写验收标准：

**6种句式**：

1. **Ubiquitous（普遍性）**
   ```
   THE [系统] SHALL [响应行为]
   示例：THE Platform SHALL支持中文和英文查询
   ```

2. **Event-driven（事件驱动）**
   ```
   WHEN [触发条件]，THE [系统] SHALL [响应行为]
   示例：WHEN User点击下载按钮，THE Platform SHALL生成48小时有效链接
   ```

3. **State-driven（状态驱动）**
   ```
   WHILE [状态条件]，THE [系统] SHALL [持续行为]
   示例：WHILE User未登录，THE Platform SHALL显示登录提示
   ```

4. **Unwanted event（异常处理）**
   ```
   IF [异常条件]，THEN THE [系统] SHALL [异常处理]
   示例：IF 下载链接过期，THEN THE Platform SHALL提示用户重新获取
   ```

5. **Optional feature（可选功能）**
   ```
   WHERE [选项条件]，THE [系统] SHALL [响应行为]
   示例：WHERE User是会员，THE Platform SHALL提供无广告下载
   ```

6. **Complex（复合条件）**
   ```
   WHERE [选项] WHILE [状态] WHEN [事件] THE [系统] SHALL [响应]
   示例：WHERE User是会员 WHILE 积分充足 WHEN 点击下载 THE Platform SHALL立即生成链接
   ```

#### 4.2 量化的成功指标

**每个阶段必须定义**：
- 用户指标：DAU、MAU、留存率
- 业务指标：转化率、收入、ROI
- 技术指标：响应时间、错误率、可用性

**示例**：
```
MVP阶段成功指标：
- DAU > 50（用户规模）
- 搜索准确率 > 70%（功能质量）
- 下载转化率 > 30%（用户价值）
- 页面加载时间 < 3秒（性能）
- 系统可用性 > 99%（稳定性）
```

#### 4.3 观测手段

**每个功能必须有观测方式**：
- 日志：记录关键操作和错误
- 监控：实时追踪性能指标
- 分析：用户行为追踪和漏斗分析
- 告警：异常情况自动通知

**基于mksaas-template的工具**：
- Vercel Analytics（性能监控）
- PostHog（用户行为分析）
- Sentry（错误监控）
- 自定义Dashboard（业务指标）

#### 4.4 避免过度设计

**只做当前阶段需要的**：
- ❌ 不要提前优化（YAGNI原则）
- ❌ 不要过度抽象（保持简单）
- ❌ 不要追求完美（快速迭代）
- ✅ 先做能用的，再做好用的

**判断标准**：
- 这个功能是否解决当前阶段的核心问题？
- 没有这个功能，用户能否完成主流程？
- 这个优化是否有数据支撑？

---

## 二、需求设计流程

### 标准流程（7步法）

```
1. 明确问题 → 2. 定义用户 → 3. 列举功能 → 4. 排序优先级 
→ 5. 设计架构 → 6. 规划阶段 → 7. 评估风险
```

### 每步的输出物

| 步骤 | 输出物 | 时间 |
|------|--------|------|
| 1. 明确问题 | 问题陈述、业务背景 | 10分钟 |
| 2. 定义用户 | 用户画像、使用场景 | 10分钟 |
| 3. 列举功能 | 功能清单、用户故事 | 30分钟 |
| 4. 排序优先级 | P0/P1/P2分类 | 20分钟 |
| 5. 设计架构 | 技术选型、数据模型、API | 30分钟 |
| 6. 规划阶段 | 4个阶段的详细计划 | 20分钟 |
| 7. 评估风险 | 风险清单、应对策略 | 20分钟 |

**总耗时：约2小时**

---

## 三、质量标准

### 一份好的需求文档应该：

✅ **完整性**
- 覆盖7个设计层面
- 包含功能需求和非功能需求
- 有明确的成功指标和验收标准

✅ **可行性**
- 技术选型基于团队能力
- 时间估算合理
- 成本在预算范围内

✅ **可验证性**
- 每个需求有EARS格式的验收标准
- 每个阶段有量化的成功指标
- 有明确的观测和监控手段

✅ **可执行性**
- 功能拆分合理，可独立开发
- 依赖关系清晰
- 有详细的技术实现方案

---

## 四、常见误区

### ❌ 误区1：需求等于功能列表
需求不是简单的功能堆砌，而是要说明为什么做、为谁做、怎么验证。

### ❌ 误区2：技术驱动需求
不要因为"想用某个技术"而设计需求，而是根据需求选择合适的技术。

### ❌ 误区3：一次性做完所有需求
应该分阶段迭代，每个阶段可独立交付和验证。

### ❌ 误区4：忽略非功能需求
性能、安全、监控同样重要，不能只关注业务功能。

### ❌ 误区5：需求文档写完就不管了
需求文档应该随着项目进展持续更新和优化。

---

## 五、最佳实践

### ✅ 实践1：用户故事驱动
每个功能都从用户故事开始，确保价值导向。

### ✅ 实践2：数据驱动决策
用数据验证假设，而不是主观判断。

### ✅ 实践3：快速迭代验证
MVP快速上线，收集反馈，持续优化。

### ✅ 实践4：技术债务管理
每个阶段预留20%时间重构和优化。

### ✅ 实践5：文档持续更新
需求文档是活文档，随项目进展持续更新。

---

**下一步**：查看 `02-提示词模板集.md` 学习如何使用AI快速生成需求文档
