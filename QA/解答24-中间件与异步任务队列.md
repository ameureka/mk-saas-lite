# 问题24：中间件设计、异步任务队列、消息中间件、缓存热搜和频率限制

## 概述

MkSaaS 采用现代化的中间件架构，支持异步任务处理、消息队列、缓存系统和频率限制。本文详细介绍系统的中间件设计、预留接口和扩展能力。

## 一、Next.js 中间件系统

### 1. 核心中间件架构

```typescript
// middleware.ts
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { rateLimit } from '@/lib/rate-limit';
import { cache } from '@/lib/cache';

export async function middleware(request: NextRequest) {
  const response = NextResponse.next();
  
  // 1. 速率限制中间件
  const rateLimitResult = await rateLimitMiddleware(request);
  if (rateLimitResult) return rateLimitResult;
  
  // 2. 认证中间件
  const authResult = await authMiddleware(request);
  if (authResult) return authResult;
  
  // 3. 缓存中间件
  const cacheResult = await cacheMiddleware(request);
  if (cacheResult) return cacheResult;
  
  // 4. 日志中间件
  await loggingMiddleware(request);
  
  // 5. 安全头中间件
  addSecurityHeaders(response);
  
  return response;
}

export const config = {
  matcher: [
    '/api/:path*',
    '/dashboard/:path*',
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
};
```

### 2. 速率限制中间件

```typescript
// src/middleware/rate-limit.ts
import { Redis } from '@upstash/redis';
import { Ratelimit } from '@upstash/ratelimit';

const redis = Redis.fromEnv();

// 创建多个速率限制器
export const rateLimiters = {
  // API 调用限制
  api: new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(100, '1 m'), // 每分钟100次
    analytics: true,
    prefix: 'ratelimit:api',
  }),
  
  // AI 模型调用限制
  ai: new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(20, '1 m'), // 每分钟20次
    analytics: true,
    prefix: 'ratelimit:ai',
  }),
  
  // 登录限制
  auth: new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(5, '15 m'), // 15分钟5次
    analytics: true,
    prefix: 'ratelimit:auth',
  }),
  
  // 支付限制
  payment: new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(3, '1 h'), // 每小时3次
    analytics: true,
    prefix: 'ratelimit:payment',
  }),
};

export async function rateLimitMiddleware(request: NextRequest) {
  const ip = request.ip ?? '127.0.0.1';
  const path = request.nextUrl.pathname;
  
  // 根据路径选择限制器
  let limiter: Ratelimit;
  
  if (path.startsWith('/api/ai')) {
    limiter = rateLimiters.ai;
  } else if (path.startsWith('/api/auth')) {
    limiter = rateLimiters.auth;
  } else if (path.startsWith('/api/payment')) {
    limiter = rateLimiters.payment;
  } else if (path.startsWith('/api')) {
    limiter = rateLimiters.api;
  } else {
    return null; // 不限制
  }
  
  const { success, limit, reset, remaining } = await limiter.limit(ip);
  
  if (!success) {
    return new NextResponse('Too Many Requests', {
      status: 429,
      headers: {
        'X-RateLimit-Limit': limit.toString(),
        'X-RateLimit-Remaining': remaining.toString(),
        'X-RateLimit-Reset': reset.toString(),
        'Retry-After': Math.ceil((reset - Date.now()) / 1000).toString(),
      },
    });
  }
  
  return null;
}
```

### 3. 用户级速率限制

```typescript
// src/lib/rate-limit/user-limit.ts
export async function checkUserRateLimit(
  userId: string,
  action: string,
  limit: number,
  window: string
): Promise<{ success: boolean; remaining: number }> {
  const key = `user:${userId}:${action}`;
  
  const limiter = new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(limit, window),
    prefix: 'ratelimit:user',
  });
  
  const result = await limiter.limit(key);
  
  return {
    success: result.success,
    remaining: result.remaining,
  };
}

// 使用示例
export async function POST(req: NextRequest) {
  const session = await auth();
  
  if (!session?.user?.id) {
    return new NextResponse('Unauthorized', { status: 401 });
  }
  
  // 检查用户级限制
  const rateLimit = await checkUserRateLimit(
    session.user.id,
    'ai-generation',
    50, // 每天50次
    '1 d'
  );
  
  if (!rateLimit.success) {
    return NextResponse.json(
      { error: '已达到每日限额', remaining: rateLimit.remaining },
      { status: 429 }
    );
  }
  
  // 处理请求...
}
```

## 二、异步任务队列系统

### 1. BullMQ 任务队列

```typescript
// src/lib/queue/index.ts
import { Queue, Worker, QueueEvents } from 'bullmq';
import { Redis } from 'ioredis';

const connection = new Redis(process.env.REDIS_URL!, {
  maxRetriesPerRequest: null,
});

// 定义任务队列
export const queues = {
  // 邮件队列
  email: new Queue('email', {
    connection,
    defaultJobOptions: {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 1000,
      },
      removeOnComplete: {
        age: 24 * 3600, // 24小时
        count: 1000,
      },
      removeOnFail: {
        age: 7 * 24 * 3600, // 7天
      },
    },
  }),
  
  // AI 处理队列
  ai: new Queue('ai', {
    connection,
    defaultJobOptions: {
      attempts: 2,
      backoff: {
        type: 'exponential',
        delay: 2000,
      },
      timeout: 60000, // 60秒超时
    },
  }),
  
  // 数据处理队列
  data: new Queue('data', {
    connection,
    defaultJobOptions: {
      attempts: 5,
      backoff: {
        type: 'exponential',
        delay: 1000,
      },
    },
  }),
  
  // 通知队列
  notification: new Queue('notification', {
    connection,
    defaultJobOptions: {
      attempts: 3,
      backoff: {
        type: 'fixed',
        delay: 5000,
      },
    },
  }),
};

// 任务类型定义
export interface EmailJob {
  to: string;
  subject: string;
  template: string;
  data: any;
}

export interface AIJob {
  userId: string;
  prompt: string;
  model: string;
  options?: any;
}

export interface DataJob {
  type: 'import' | 'export' | 'sync';
  userId: string;
  data: any;
}

// 添加任务到队列
export async function addEmailJob(data: EmailJob, options?: any) {
  return queues.email.add('send-email', data, options);
}

export async function addAIJob(data: AIJob, options?: any) {
  return queues.ai.add('process-ai', data, options);
}

export async function addDataJob(data: DataJob, options?: any) {
  return queues.data.add('process-data', data, options);
}
```

### 2. Worker 处理器

```typescript
// src/lib/queue/workers/email-worker.ts
import { Worker, Job } from 'bullmq';
import { mailService } from '@/lib/mail';

export const emailWorker = new Worker(
  'email',
  async (job: Job<EmailJob>) => {
    console.log(`Processing email job ${job.id}`);
    
    const { to, subject, template, data } = job.data;
    
    // 发送邮件
    const result = await mailService.send({
      to,
      subject,
      template,
      data,
    });
    
    // 更新进度
    await job.updateProgress(100);
    
    return result;
  },
  {
    connection,
    concurrency: 10, // 并发处理10个任务
    limiter: {
      max: 100, // 每秒最多100个任务
      duration: 1000,
    },
  }
);

// 事件监听
emailWorker.on('completed', (job, result) => {
  console.log(`Email job ${job.id} completed:`, result);
});

emailWorker.on('failed', (job, err) => {
  console.error(`Email job ${job?.id} failed:`, err);
});

emailWorker.on('progress', (job, progress) => {
  console.log(`Email job ${job.id} progress: ${progress}%`);
});
```

### 3. AI 处理 Worker

```typescript
// src/lib/queue/workers/ai-worker.ts
export const aiWorker = new Worker(
  'ai',
  async (job: Job<AIJob>) => {
    console.log(`Processing AI job ${job.id}`);
    
    const { userId, prompt, model, options } = job.data;
    
    try {
      // 调用 AI 模型
      const result = await generateAIResponse({
        prompt,
        model,
        options,
      });
      
      // 保存结果到数据库
      await db.insert(aiGenerations).values({
        userId,
        prompt,
        response: result.text,
        model,
        tokens: result.tokens,
      });
      
      // 扣除积分
      await deductCredits(userId, result.tokens);
      
      await job.updateProgress(100);
      
      return result;
    } catch (error) {
      // 记录错误
      await db.insert(aiErrors).values({
        userId,
        prompt,
        model,
        error: error.message,
      });
      
      throw error;
    }
  },
  {
    connection,
    concurrency: 5, // AI 任务并发较低
    limiter: {
      max: 20,
      duration: 60000, // 每分钟20个
    },
  }
);
```

### 4. 定时任务

```typescript
// src/lib/queue/scheduled-jobs.ts
import { Queue } from 'bullmq';

// 添加定时任务
export async function scheduleRecurringJobs() {
  // 每日统计报告
  await queues.data.add(
    'daily-stats',
    { type: 'stats', period: 'daily' },
    {
      repeat: {
        pattern: '0 9 * * *', // 每天早上9点
        tz: 'Asia/Shanghai',
      },
    }
  );
  
  // 每周清理
  await queues.data.add(
    'weekly-cleanup',
    { type: 'cleanup' },
    {
      repeat: {
        pattern: '0 2 * * 0', // 每周日凌晨2点
        tz: 'Asia/Shanghai',
      },
    }
  );
  
  // 每小时更新热搜
  await queues.data.add(
    'update-trending',
    { type: 'trending' },
    {
      repeat: {
        pattern: '0 * * * *', // 每小时
      },
    }
  );
}
```

## 三、缓存系统

### 1. Redis 缓存层

```typescript
// src/lib/cache/redis-cache.ts
import { Redis } from '@upstash/redis';

const redis = Redis.fromEnv();

export class CacheService {
  // 获取缓存
  async get<T>(key: string): Promise<T | null> {
    const value = await redis.get(key);
    return value as T | null;
  }
  
  // 设置缓存
  async set(key: string, value: any, ttl?: number): Promise<void> {
    if (ttl) {
      await redis.setex(key, ttl, JSON.stringify(value));
    } else {
      await redis.set(key, JSON.stringify(value));
    }
  }
  
  // 删除缓存
  async del(key: string): Promise<void> {
    await redis.del(key);
  }
  
  // 批量删除
  async delPattern(pattern: string): Promise<void> {
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
  }
  
  // 缓存穿透保护
  async getOrSet<T>(
    key: string,
    fetcher: () => Promise<T>,
    ttl: number = 3600
  ): Promise<T> {
    // 尝试从缓存获取
    const cached = await this.get<T>(key);
    if (cached !== null) {
      return cached;
    }
    
    // 缓存未命中，获取数据
    const value = await fetcher();
    
    // 存入缓存
    await this.set(key, value, ttl);
    
    return value;
  }
  
  // 增量操作
  async incr(key: string, amount: number = 1): Promise<number> {
    return redis.incrby(key, amount);
  }
  
  // 减量操作
  async decr(key: string, amount: number = 1): Promise<number> {
    return redis.decrby(key, amount);
  }
}

export const cache = new CacheService();
```

### 2. 热搜缓存

```typescript
// src/lib/cache/trending.ts
export class TrendingCache {
  private readonly prefix = 'trending:';
  
  // 记录搜索
  async recordSearch(query: string): Promise<void> {
    const key = `${this.prefix}search`;
    await redis.zincrby(key, 1, query);
    
    // 设置过期时间（7天）
    await redis.expire(key, 7 * 24 * 3600);
  }
  
  // 获取热搜
  async getTrending(limit: number = 10): Promise<string[]> {
    const key = `${this.prefix}search`;
    return redis.zrevrange(key, 0, limit - 1);
  }
  
  // 获取热搜带分数
  async getTrendingWithScores(limit: number = 10) {
    const key = `${this.prefix}search`;
    const results = await redis.zrevrange(key, 0, limit - 1, {
      withScores: true,
    });
    
    const trending = [];
    for (let i = 0; i < results.length; i += 2) {
      trending.push({
        query: results[i],
        score: results[i + 1],
      });
    }
    
    return trending;
  }
  
  // 记录内容浏览
  async recordView(contentId: string): Promise<void> {
    const key = `${this.prefix}content`;
    await redis.zincrby(key, 1, contentId);
    await redis.expire(key, 24 * 3600); // 24小时
  }
  
  // 获取热门内容
  async getTrendingContent(limit: number = 10): Promise<string[]> {
    const key = `${this.prefix}content`;
    return redis.zrevrange(key, 0, limit - 1);
  }
}

export const trendingCache = new TrendingCache();
```

### 3. 多级缓存

```typescript
// src/lib/cache/multi-level-cache.ts
import { LRUCache } from 'lru-cache';

// 内存缓存（L1）
const memoryCache = new LRUCache<string, any>({
  max: 500, // 最多500个条目
  ttl: 1000 * 60 * 5, // 5分钟
  updateAgeOnGet: true,
});

export class MultiLevelCache {
  // 获取缓存（先内存，后Redis）
  async get<T>(key: string): Promise<T | null> {
    // L1: 内存缓存
    const memValue = memoryCache.get(key);
    if (memValue !== undefined) {
      return memValue as T;
    }
    
    // L2: Redis 缓存
    const redisValue = await cache.get<T>(key);
    if (redisValue !== null) {
      // 回填内存缓存
      memoryCache.set(key, redisValue);
      return redisValue;
    }
    
    return null;
  }
  
  // 设置缓存（同时写入内存和Redis）
  async set(key: string, value: any, ttl?: number): Promise<void> {
    memoryCache.set(key, value);
    await cache.set(key, value, ttl);
  }
  
  // 删除缓存
  async del(key: string): Promise<void> {
    memoryCache.delete(key);
    await cache.del(key);
  }
}

export const multiCache = new MultiLevelCache();
```


## 四、消息中间件

### 1. 事件总线

```typescript
// src/lib/events/event-bus.ts
import { EventEmitter } from 'events';

export class EventBus extends EventEmitter {
  private static instance: EventBus;
  
  private constructor() {
    super();
    this.setMaxListeners(100);
  }
  
  static getInstance(): EventBus {
    if (!EventBus.instance) {
      EventBus.instance = new EventBus();
    }
    return EventBus.instance;
  }
  
  // 发布事件
  publish(event: string, data: any): void {
    this.emit(event, data);
  }
  
  // 订阅事件
  subscribe(event: string, handler: (data: any) => void): void {
    this.on(event, handler);
  }
  
  // 取消订阅
  unsubscribe(event: string, handler: (data: any) => void): void {
    this.off(event, handler);
  }
}

export const eventBus = EventBus.getInstance();

// 事件类型定义
export enum Events {
  USER_REGISTERED = 'user:registered',
  USER_LOGGED_IN = 'user:logged_in',
  PAYMENT_SUCCESS = 'payment:success',
  CONTENT_CREATED = 'content:created',
  AI_GENERATED = 'ai:generated',
}
```

### 2. Redis Pub/Sub

```typescript
// src/lib/events/redis-pubsub.ts
import { Redis } from 'ioredis';

const publisher = new Redis(process.env.REDIS_URL!);
const subscriber = new Redis(process.env.REDIS_URL!);

export class RedisPubSub {
  // 发布消息
  async publish(channel: string, message: any): Promise<void> {
    await publisher.publish(channel, JSON.stringify(message));
  }
  
  // 订阅频道
  subscribe(channel: string, handler: (message: any) => void): void {
    subscriber.subscribe(channel);
    
    subscriber.on('message', (ch, msg) => {
      if (ch === channel) {
        try {
          const data = JSON.parse(msg);
          handler(data);
        } catch (error) {
          console.error('Failed to parse message:', error);
        }
      }
    });
  }
  
  // 取消订阅
  async unsubscribe(channel: string): Promise<void> {
    await subscriber.unsubscribe(channel);
  }
}

export const redisPubSub = new RedisPubSub();

// 使用示例
redisPubSub.subscribe('notifications', (message) => {
  console.log('Received notification:', message);
  // 处理通知
});
```

### 3. Webhook 系统

```typescript
// src/lib/webhooks/webhook-manager.ts
export interface Webhook {
  id: string;
  url: string;
  events: string[];
  secret: string;
  active: boolean;
}

export class WebhookManager {
  // 触发 Webhook
  async trigger(event: string, data: any): Promise<void> {
    // 查询订阅此事件的 Webhooks
    const webhooks = await db.query.webhooks.findMany({
      where: and(
        eq(webhooks.active, true),
        sql`${event} = ANY(${webhooks.events})`
      ),
    });
    
    // 并发发送
    await Promise.all(
      webhooks.map(webhook => this.sendWebhook(webhook, event, data))
    );
  }
  
  // 发送 Webhook
  private async sendWebhook(
    webhook: Webhook,
    event: string,
    data: any
  ): Promise<void> {
    const payload = {
      event,
      data,
      timestamp: Date.now(),
    };
    
    // 生成签名
    const signature = this.generateSignature(payload, webhook.secret);
    
    try {
      const response = await fetch(webhook.url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Webhook-Signature': signature,
          'X-Webhook-Event': event,
        },
        body: JSON.stringify(payload),
      });
      
      // 记录日志
      await db.insert(webhookLogs).values({
        webhookId: webhook.id,
        event,
        status: response.status,
        response: await response.text(),
      });
    } catch (error) {
      console.error('Webhook failed:', error);
      
      // 记录失败
      await db.insert(webhookLogs).values({
        webhookId: webhook.id,
        event,
        status: 0,
        error: error.message,
      });
    }
  }
  
  private generateSignature(payload: any, secret: string): string {
    const hmac = createHmac('sha256', secret);
    hmac.update(JSON.stringify(payload));
    return hmac.digest('hex');
  }
}

export const webhookManager = new WebhookManager();
```

## 五、预留接口设计

### 1. 插件系统接口

```typescript
// src/lib/plugins/plugin-interface.ts
export interface Plugin {
  name: string;
  version: string;
  
  // 生命周期钩子
  onInstall?(): Promise<void>;
  onUninstall?(): Promise<void>;
  onEnable?(): Promise<void>;
  onDisable?(): Promise<void>;
  
  // 功能钩子
  onBeforeRequest?(req: Request): Promise<Request>;
  onAfterResponse?(res: Response): Promise<Response>;
  onError?(error: Error): Promise<void>;
}

export class PluginManager {
  private plugins: Map<string, Plugin> = new Map();
  
  // 注册插件
  register(plugin: Plugin): void {
    this.plugins.set(plugin.name, plugin);
  }
  
  // 执行钩子
  async executeHook(
    hookName: keyof Plugin,
    ...args: any[]
  ): Promise<any> {
    for (const plugin of this.plugins.values()) {
      const hook = plugin[hookName];
      if (typeof hook === 'function') {
        await hook.apply(plugin, args);
      }
    }
  }
}

export const pluginManager = new PluginManager();
```

### 2. 扩展点接口

```typescript
// src/lib/extensions/extension-points.ts
export interface ExtensionPoint<T = any> {
  name: string;
  execute(context: T): Promise<T>;
}

export class ExtensionRegistry {
  private extensions: Map<string, ExtensionPoint[]> = new Map();
  
  // 注册扩展
  register(point: string, extension: ExtensionPoint): void {
    if (!this.extensions.has(point)) {
      this.extensions.set(point, []);
    }
    this.extensions.get(point)!.push(extension);
  }
  
  // 执行扩展点
  async execute<T>(point: string, context: T): Promise<T> {
    const extensions = this.extensions.get(point) || [];
    
    let result = context;
    for (const extension of extensions) {
      result = await extension.execute(result);
    }
    
    return result;
  }
}

export const extensionRegistry = new ExtensionRegistry();

// 使用示例：内容处理扩展点
extensionRegistry.register('content:beforeSave', {
  name: 'seo-optimizer',
  async execute(content) {
    // 自动优化 SEO
    content.metaDescription = generateMetaDescription(content.body);
    return content;
  },
});
```

### 3. 中间件链接口

```typescript
// src/lib/middleware/middleware-chain.ts
export type Middleware<T = any> = (
  context: T,
  next: () => Promise<T>
) => Promise<T>;

export class MiddlewareChain<T = any> {
  private middlewares: Middleware<T>[] = [];
  
  // 添加中间件
  use(middleware: Middleware<T>): this {
    this.middlewares.push(middleware);
    return this;
  }
  
  // 执行中间件链
  async execute(context: T): Promise<T> {
    let index = 0;
    
    const next = async (): Promise<T> => {
      if (index >= this.middlewares.length) {
        return context;
      }
      
      const middleware = this.middlewares[index++];
      return middleware(context, next);
    };
    
    return next();
  }
}

// 使用示例
const apiChain = new MiddlewareChain();

apiChain
  .use(async (ctx, next) => {
    // 日志中间件
    console.log('Request:', ctx.url);
    return next();
  })
  .use(async (ctx, next) => {
    // 认证中间件
    if (!ctx.user) {
      throw new Error('Unauthorized');
    }
    return next();
  })
  .use(async (ctx, next) => {
    // 业务逻辑
    ctx.result = await processRequest(ctx);
    return next();
  });
```

## 六、频率限制高级策略

### 1. 令牌桶算法

```typescript
// src/lib/rate-limit/token-bucket.ts
export class TokenBucket {
  private tokens: number;
  private lastRefill: number;
  
  constructor(
    private capacity: number,
    private refillRate: number, // 每秒补充的令牌数
  ) {
    this.tokens = capacity;
    this.lastRefill = Date.now();
  }
  
  // 尝试消费令牌
  async consume(tokens: number = 1): Promise<boolean> {
    this.refill();
    
    if (this.tokens >= tokens) {
      this.tokens -= tokens;
      return true;
    }
    
    return false;
  }
  
  // 补充令牌
  private refill(): void {
    const now = Date.now();
    const elapsed = (now - this.lastRefill) / 1000;
    const tokensToAdd = elapsed * this.refillRate;
    
    this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }
  
  // 获取剩余令牌
  getRemaining(): number {
    this.refill();
    return Math.floor(this.tokens);
  }
}
```

### 2. 滑动窗口限制

```typescript
// src/lib/rate-limit/sliding-window.ts
export class SlidingWindowRateLimit {
  constructor(
    private redis: Redis,
    private limit: number,
    private window: number, // 窗口大小（秒）
  ) {}
  
  async check(key: string): Promise<{ allowed: boolean; remaining: number }> {
    const now = Date.now();
    const windowStart = now - this.window * 1000;
    
    // 清理过期记录
    await this.redis.zremrangebyscore(key, 0, windowStart);
    
    // 获取当前窗口内的请求数
    const count = await this.redis.zcard(key);
    
    if (count < this.limit) {
      // 添加当前请求
      await this.redis.zadd(key, now, `${now}-${Math.random()}`);
      await this.redis.expire(key, this.window);
      
      return {
        allowed: true,
        remaining: this.limit - count - 1,
      };
    }
    
    return {
      allowed: false,
      remaining: 0,
    };
  }
}
```

### 3. 分布式限流

```typescript
// src/lib/rate-limit/distributed-limiter.ts
export class DistributedRateLimiter {
  constructor(
    private redis: Redis,
    private config: {
      points: number; // 允许的点数
      duration: number; // 时间窗口（秒）
      blockDuration?: number; // 阻塞时长（秒）
    }
  ) {}
  
  async consume(key: string, points: number = 1): Promise<RateLimitResult> {
    const now = Date.now();
    const windowKey = `ratelimit:${key}`;
    const blockKey = `ratelimit:block:${key}`;
    
    // 检查是否被阻塞
    const blocked = await this.redis.get(blockKey);
    if (blocked) {
      const ttl = await this.redis.ttl(blockKey);
      return {
        allowed: false,
        remaining: 0,
        resetAt: now + ttl * 1000,
      };
    }
    
    // Lua 脚本实现原子操作
    const script = `
      local key = KEYS[1]
      local limit = tonumber(ARGV[1])
      local window = tonumber(ARGV[2])
      local points = tonumber(ARGV[3])
      local now = tonumber(ARGV[4])
      
      local current = redis.call('GET', key)
      if current == false then
        current = 0
      else
        current = tonumber(current)
      end
      
      if current + points <= limit then
        redis.call('INCRBY', key, points)
        redis.call('EXPIRE', key, window)
        return {1, limit - current - points}
      else
        return {0, 0}
      end
    `;
    
    const result = await this.redis.eval(
      script,
      1,
      windowKey,
      this.config.points,
      this.config.duration,
      points,
      now
    );
    
    const [allowed, remaining] = result as [number, number];
    
    // 如果超限且配置了阻塞时长
    if (!allowed && this.config.blockDuration) {
      await this.redis.setex(
        blockKey,
        this.config.blockDuration,
        '1'
      );
    }
    
    return {
      allowed: allowed === 1,
      remaining,
      resetAt: now + this.config.duration * 1000,
    };
  }
}
```

## 七、监控与可观测性

### 1. 队列监控

```typescript
// src/lib/monitoring/queue-monitor.ts
import { QueueEvents } from 'bullmq';

export class QueueMonitor {
  private events: QueueEvents;
  
  constructor(queueName: string) {
    this.events = new QueueEvents(queueName, { connection });
    this.setupListeners();
  }
  
  private setupListeners(): void {
    // 任务完成
    this.events.on('completed', ({ jobId, returnvalue }) => {
      console.log(`Job ${jobId} completed`);
      this.recordMetric('job.completed', 1);
    });
    
    // 任务失败
    this.events.on('failed', ({ jobId, failedReason }) => {
      console.error(`Job ${jobId} failed:`, failedReason);
      this.recordMetric('job.failed', 1);
    });
    
    // 任务延迟
    this.events.on('delayed', ({ jobId, delay }) => {
      console.log(`Job ${jobId} delayed by ${delay}ms`);
      this.recordMetric('job.delayed', 1);
    });
  }
  
  private recordMetric(name: string, value: number): void {
    // 发送到监控系统（如 Prometheus、DataDog）
    // metrics.increment(name, value);
  }
  
  // 获取队列统计
  async getStats(queue: Queue): Promise<QueueStats> {
    const [waiting, active, completed, failed, delayed] = await Promise.all([
      queue.getWaitingCount(),
      queue.getActiveCount(),
      queue.getCompletedCount(),
      queue.getFailedCount(),
      queue.getDelayedCount(),
    ]);
    
    return {
      waiting,
      active,
      completed,
      failed,
      delayed,
      total: waiting + active + completed + failed + delayed,
    };
  }
}
```

### 2. 缓存监控

```typescript
// src/lib/monitoring/cache-monitor.ts
export class CacheMonitor {
  private hits = 0;
  private misses = 0;
  
  recordHit(): void {
    this.hits++;
  }
  
  recordMiss(): void {
    this.misses++;
  }
  
  getHitRate(): number {
    const total = this.hits + this.misses;
    return total > 0 ? this.hits / total : 0;
  }
  
  getStats() {
    return {
      hits: this.hits,
      misses: this.misses,
      hitRate: this.getHitRate(),
    };
  }
  
  reset(): void {
    this.hits = 0;
    this.misses = 0;
  }
}

export const cacheMonitor = new CacheMonitor();
```

## 八、配置管理

### 1. 环境配置

```env
# .env.local

# Redis
REDIS_URL=redis://localhost:6379
UPSTASH_REDIS_REST_URL=https://xxx.upstash.io
UPSTASH_REDIS_REST_TOKEN=xxx

# 队列配置
QUEUE_CONCURRENCY=10
QUEUE_MAX_RETRIES=3

# 速率限制
RATE_LIMIT_API=100
RATE_LIMIT_AI=20
RATE_LIMIT_AUTH=5

# 缓存配置
CACHE_TTL=3600
CACHE_MAX_SIZE=500

# 监控
ENABLE_MONITORING=true
METRICS_ENDPOINT=https://metrics.example.com
```

### 2. 动态配置

```typescript
// src/lib/config/dynamic-config.ts
export class DynamicConfig {
  private config: Map<string, any> = new Map();
  
  async load(): Promise<void> {
    // 从数据库或配置中心加载
    const configs = await db.query.configs.findMany();
    
    configs.forEach(config => {
      this.config.set(config.key, config.value);
    });
  }
  
  get<T>(key: string, defaultValue?: T): T {
    return this.config.get(key) ?? defaultValue;
  }
  
  async set(key: string, value: any): Promise<void> {
    this.config.set(key, value);
    
    // 持久化到数据库
    await db.insert(configs)
      .values({ key, value })
      .onConflictDoUpdate({
        target: configs.key,
        set: { value, updatedAt: new Date() },
      });
  }
}

export const dynamicConfig = new DynamicConfig();
```

## 总结

MkSaaS 提供了完整的中间件和异步处理架构：

1. **中间件系统**: 速率限制、认证、缓存、日志
2. **异步任务队列**: BullMQ 多队列支持
3. **消息中间件**: 事件总线、Redis Pub/Sub、Webhook
4. **缓存系统**: 多级缓存、热搜缓存
5. **频率限制**: 多种算法、分布式限流
6. **预留接口**: 插件系统、扩展点、中间件链
7. **监控系统**: 队列监控、缓存监控

所有系统都预留了扩展接口，支持灵活定制和扩展。
