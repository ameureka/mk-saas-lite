# 问题15：如何设计不同大模型以及状态以及使用的降级处理，这样的模式如何从前端以及后端控制

## 概述

在 AI 应用中，模型降级是确保服务可用性和成本控制的关键策略。MkSaaS 实现了完整的模型降级机制，包括自动降级、手动选择、错误重试和状态管理。

## 一、模型降级架构

### 1. 降级策略层级

```
降级策略:

Level 1: 首选模型 (Primary)
├── GPT-4 Turbo
├── Claude 3 Opus
└── Gemini Pro

Level 2: 备用模型 (Fallback)
├── GPT-4
├── Claude 3 Sonnet
└── Gemini Pro

Level 3: 经济模型 (Economy)
├── GPT-3.5 Turbo
├── Claude 3 Haiku
└── Gemini Flash

Level 4: 本地模型 (Local)
├── Llama 3
├── Mistral
└── 缓存响应
```

### 2. 降级触发条件

```typescript
// src/lib/ai/degradation-triggers.ts
export enum DegradationReason {
  API_ERROR = 'api_error',           // API 错误
  RATE_LIMIT = 'rate_limit',         // 速率限制
  TIMEOUT = 'timeout',               // 超时
  INSUFFICIENT_CREDITS = 'insufficient_credits', // 积分不足
  MODEL_UNAVAILABLE = 'model_unavailable',      // 模型不可用
  COST_OPTIMIZATION = 'cost_optimization',      // 成本优化
  USER_PREFERENCE = 'user_preference',          // 用户偏好
}

export interface DegradationTrigger {
  reason: DegradationReason;
  shouldDegrade: boolean;
  suggestedModel?: string;
  retryAfter?: number;
}
```

## 二、模型配置系统

### 1. 模型配置定义

```typescript
// src/config/ai-models.ts
export interface ModelTier {
  tier: 'premium' | 'standard' | 'economy' | 'local';
  priority: number;
}

export interface ModelConfig {
  id: string;
  name: string;
  provider: string;
  tier: ModelTier;
  
  // 性能指标
  performance: {
    speed: number;        // 1-10
    quality: number;      // 1-10
    costEfficiency: number; // 1-10
  };
  
  // 使用限制
  limits: {
    maxTokens: number;
    contextWindow: number;
    requestsPerMinute: number;
  };
  
  // 成本
  cost: {
    inputTokens: number;   // 每1K tokens
    outputTokens: number;  // 每1K tokens
    credits: number;       // 每次请求消耗的积分
  };
  
  // 降级配置
  fallback: {
    enabled: boolean;
    models: string[];      // 降级模型列表
    retryAttempts: number;
    retryDelay: number;    // 毫秒
  };
  
  // 可用性
  availability: {
    enabled: boolean;
    requiredPlan: 'free' | 'pro' | 'lifetime';
    regions?: string[];
  };
}

export const modelConfigs: Record<string, ModelConfig> = {
  'gpt-4-turbo': {
    id: 'gpt-4-turbo',
    name: 'GPT-4 Turbo',
    provider: 'openai',
    tier: {
      tier: 'premium',
      priority: 1,
    },
    performance: {
      speed: 7,
      quality: 10,
      costEfficiency: 6,
    },
    limits: {
      maxTokens: 4096,
      contextWindow: 128000,
      requestsPerMinute: 20,
    },
    cost: {
      inputTokens: 0.01,
      outputTokens: 0.03,
      credits: 10,
    },
    fallback: {
      enabled: true,
      models: ['gpt-4', 'gpt-3.5-turbo'],
      retryAttempts: 3,
      retryDelay: 1000,
    },
    availability: {
      enabled: true,
      requiredPlan: 'pro',
    },
  },
  
  'gpt-3.5-turbo': {
    id: 'gpt-3.5-turbo',
    name: 'GPT-3.5 Turbo',
    provider: 'openai',
    tier: {
      tier: 'economy',
      priority: 3,
    },
    performance: {
      speed: 9,
      quality: 7,
      costEfficiency: 9,
    },
    limits: {
      maxTokens: 4096,
      contextWindow: 16385,
      requestsPerMinute: 60,
    },
    cost: {
      inputTokens: 0.0005,
      outputTokens: 0.0015,
      credits: 1,
    },
    fallback: {
      enabled: true,
      models: ['deepseek-chat'],
      retryAttempts: 2,
      retryDelay: 500,
    },
    availability: {
      enabled: true,
      requiredPlan: 'free',
    },
  },
  
  'claude-3-opus': {
    id: 'claude-3-opus',
    name: 'Claude 3 Opus',
    provider: 'anthropic',
    tier: {
      tier: 'premium',
      priority: 1,
    },
    performance: {
      speed: 6,
      quality: 10,
      costEfficiency: 5,
    },
    limits: {
      maxTokens: 4096,
      contextWindow: 200000,
      requestsPerMinute: 15,
    },
    cost: {
      inputTokens: 0.015,
      outputTokens: 0.075,
      credits: 15,
    },
    fallback: {
      enabled: true,
      models: ['claude-3-sonnet', 'claude-3-haiku'],
      retryAttempts: 3,
      retryDelay: 1000,
    },
    availability: {
      enabled: true,
      requiredPlan: 'lifetime',
    },
  },
  
  'deepseek-chat': {
    id: 'deepseek-chat',
    name: 'DeepSeek Chat',
    provider: 'deepseek',
    tier: {
      tier: 'economy',
      priority: 4,
    },
    performance: {
      speed: 8,
      quality: 7,
      costEfficiency: 10,
    },
    limits: {
      maxTokens: 4096,
      contextWindow: 32768,
      requestsPerMinute: 100,
    },
    cost: {
      inputTokens: 0.0001,
      outputTokens: 0.0002,
      credits: 0.5,
    },
    fallback: {
      enabled: false,
      models: [],
      retryAttempts: 2,
      retryDelay: 500,
    },
    availability: {
      enabled: true,
      requiredPlan: 'free',
    },
  },
};
```

### 2. 模型选择器

```typescript
// src/lib/ai/model-selector.ts
import { modelConfigs, ModelConfig } from '@/config/ai-models';
import { getCurrentPlan } from '@/lib/price-plan';
import { getCreditBalance } from '@/credits/server';

export interface ModelSelectionCriteria {
  userId: string;
  preferredModel?: string;
  task: 'chat' | 'completion' | 'embedding' | 'image';
  priority: 'quality' | 'speed' | 'cost';
  maxCost?: number;
}

export async function selectBestModel(
  criteria: ModelSelectionCriteria
): Promise<{
  model: ModelConfig;
  reason: string;
}> {
  const { userId, preferredModel, priority, maxCost } = criteria;
  
  // 获取用户计划和积分
  const [currentPlan, creditBalance] = await Promise.all([
    getCurrentPlan(userId),
    getCreditBalance(userId),
  ]);
  
  // 过滤可用模型
  const availableModels = Object.values(modelConfigs).filter(model => {
    // 检查是否启用
    if (!model.availability.enabled) return false;
    
    // 检查计划要求
    const planHierarchy = ['free', 'pro', 'lifetime'];
    const userPlanLevel = planHierarchy.indexOf(currentPlan.id);
    const requiredPlanLevel = planHierarchy.indexOf(model.availability.requiredPlan);
    if (userPlanLevel < requiredPlanLevel) return false;
    
    // 检查积分
    if (creditBalance < model.cost.credits) return false;
    
    // 检查成本限制
    if (maxCost && model.cost.credits > maxCost) return false;
    
    return true;
  });
  
  if (availableModels.length === 0) {
    throw new Error('No available models');
  }
  
  // 如果指定了首选模型且可用，使用它
  if (preferredModel) {
    const preferred = availableModels.find(m => m.id === preferredModel);
    if (preferred) {
      return {
        model: preferred,
        reason: 'User preference',
      };
    }
  }
  
  // 根据优先级排序
  const sorted = availableModels.sort((a, b) => {
    switch (priority) {
      case 'quality':
        return b.performance.quality - a.performance.quality;
      case 'speed':
        return b.performance.speed - a.performance.speed;
      case 'cost':
        return b.performance.costEfficiency - a.performance.costEfficiency;
      default:
        return a.tier.priority - b.tier.priority;
    }
  });
  
  return {
    model: sorted[0],
    reason: `Best ${priority} option`,
  };
}
```

## 三、降级处理实现

### 1. 自动降级引擎

```typescript
// src/lib/ai/degradation-engine.ts
import { modelConfigs, ModelConfig } from '@/config/ai-models';
import { DegradationReason, DegradationTrigger } from './degradation-triggers';

export class DegradationEngine {
  private attemptCount: Map<string, number> = new Map();
  
  /**
   * 检查是否需要降级
   */
  shouldDegrade(
    modelId: string,
    error: Error
  ): DegradationTrigger {
    const model = modelConfigs[modelId];
    
    if (!model) {
      return {
        reason: DegradationReason.MODEL_UNAVAILABLE,
        shouldDegrade: true,
      };
    }
    
    // 检查错误类型
    if (error.message.includes('rate limit')) {
      return {
        reason: DegradationReason.RATE_LIMIT,
        shouldDegrade: true,
        retryAfter: 60,
      };
    }
    
    if (error.message.includes('timeout')) {
      return {
        reason: DegradationReason.TIMEOUT,
        shouldDegrade: true,
      };
    }
    
    if (error.message.includes('insufficient credits')) {
      return {
        reason: DegradationReason.INSUFFICIENT_CREDITS,
        shouldDegrade: true,
        suggestedModel: this.getCheaperModel(modelId),
      };
    }
    
    // 检查重试次数
    const attempts = this.attemptCount.get(modelId) || 0;
    if (attempts >= model.fallback.retryAttempts) {
      return {
        reason: DegradationReason.API_ERROR,
        shouldDegrade: true,
      };
    }
    
    return {
      reason: DegradationReason.API_ERROR,
      shouldDegrade: false,
    };
  }
  
  /**
   * 获取降级模型
   */
  getDegradedModel(
    currentModelId: string,
    reason: DegradationReason
  ): string | null {
    const model = modelConfigs[currentModelId];
    
    if (!model || !model.fallback.enabled) {
      return null;
    }
    
    // 根据原因选择降级策略
    const fallbackModels = model.fallback.models;
    
    if (fallbackModels.length === 0) {
      return null;
    }
    
    // 返回第一个可用的降级模型
    for (const fallbackId of fallbackModels) {
      const fallbackModel = modelConfigs[fallbackId];
      if (fallbackModel && fallbackModel.availability.enabled) {
        return fallbackId;
      }
    }
    
    return null;
  }
  
  /**
   * 获取更便宜的模型
   */
  private getCheaperModel(currentModelId: string): string | null {
    const currentModel = modelConfigs[currentModelId];
    if (!currentModel) return null;
    
    const cheaperModels = Object.values(modelConfigs)
      .filter(m => 
        m.availability.enabled &&
        m.cost.credits < currentModel.cost.credits
      )
      .sort((a, b) => b.performance.quality - a.performance.quality);
    
    return cheaperModels[0]?.id || null;
  }
  
  /**
   * 记录尝试次数
   */
  recordAttempt(modelId: string) {
    const current = this.attemptCount.get(modelId) || 0;
    this.attemptCount.set(modelId, current + 1);
  }
  
  /**
   * 重置尝试次数
   */
  resetAttempts(modelId: string) {
    this.attemptCount.delete(modelId);
  }
}
```

### 2. 带降级的 AI 调用

```typescript
// src/lib/ai/resilient-generate.ts
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';
import { anthropic } from '@ai-sdk/anthropic';
import { google } from '@ai-sdk/google';
import { deepseek } from '@ai-sdk/deepseek';
import { modelConfigs } from '@/config/ai-models';
import { DegradationEngine } from './degradation-engine';

const degradationEngine = new DegradationEngine();

// 模型提供商映射
const providerMap = {
  openai,
  anthropic,
  google,
  deepseek,
};

export interface ResilientGenerateOptions {
  modelId: string;
  prompt: string;
  userId: string;
  maxRetries?: number;
  onDegrade?: (oldModel: string, newModel: string, reason: string) => void;
}

export async function resilientGenerate(
  options: ResilientGenerateOptions
): Promise<{
  text: string;
  modelUsed: string;
  degraded: boolean;
  attempts: number;
}> {
  const { modelId, prompt, userId, maxRetries = 3, onDegrade } = options;
  
  let currentModelId = modelId;
  let attempts = 0;
  let degraded = false;
  
  while (attempts < maxRetries) {
    attempts++;
    
    try {
      const model = modelConfigs[currentModelId];
      
      if (!model) {
        throw new Error(`Model ${currentModelId} not found`);
      }
      
      // 获取提供商
      const provider = providerMap[model.provider];
      if (!provider) {
        throw new Error(`Provider ${model.provider} not supported`);
      }
      
      // 记录尝试
      degradationEngine.recordAttempt(currentModelId);
      
      // 调用 AI
      const { text } = await generateText({
        model: provider(currentModelId),
        prompt,
        maxTokens: model.limits.maxTokens,
      });
      
      // 成功，重置计数
      degradationEngine.resetAttempts(currentModelId);
      
      return {
        text,
        modelUsed: currentModelId,
        degraded,
        attempts,
      };
      
    } catch (error) {
      console.error(`Error with model ${currentModelId}:`, error);
      
      // 检查是否需要降级
      const trigger = degradationEngine.shouldDegrade(
        currentModelId,
        error as Error
      );
      
      if (!trigger.shouldDegrade) {
        // 不需要降级，等待后重试
        const model = modelConfigs[currentModelId];
        await new Promise(resolve => 
          setTimeout(resolve, model.fallback.retryDelay)
        );
        continue;
      }
      
      // 获取降级模型
      const degradedModelId = trigger.suggestedModel || 
        degradationEngine.getDegradedModel(currentModelId, trigger.reason);
      
      if (!degradedModelId) {
        // 没有可用的降级模型
        throw new Error(
          `Failed with model ${currentModelId} and no fallback available`
        );
      }
      
      // 通知降级
      if (onDegrade) {
        onDegrade(currentModelId, degradedModelId, trigger.reason);
      }
      
      console.log(
        `Degrading from ${currentModelId} to ${degradedModelId} ` +
        `(reason: ${trigger.reason})`
      );
      
      // 切换到降级模型
      currentModelId = degradedModelId;
      degraded = true;
      
      // 重置新模型的尝试计数
      degradationEngine.resetAttempts(currentModelId);
      
      // 如果有重试延迟，等待
      if (trigger.retryAfter) {
        await new Promise(resolve => 
          setTimeout(resolve, trigger.retryAfter! * 1000)
        );
      }
    }
  }
  
  throw new Error(`Failed after ${attempts} attempts`);
}
```

## 四、后端实现

### 1. API 路由集成

```typescript
// src/app/api/ai/chat/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { requireAuth } from '@/lib/api-middleware';
import { resilientGenerate } from '@/lib/ai/resilient-generate';
import { selectBestModel } from '@/lib/ai/model-selector';
import { consumeModelCredits } from '@/lib/ai/credit-check';
import { logApiUsage } from '@/lib/audit-log';

export async function POST(req: NextRequest) {
  const session = await requireAuth(req);
  
  if (session instanceof NextResponse) {
    return session;
  }
  
  const { 
    prompt, 
    preferredModel, 
    priority = 'quality' 
  } = await req.json();
  
  try {
    // 1. 选择最佳模型
    const { model, reason } = await selectBestModel({
      userId: session.user.id,
      preferredModel,
      task: 'completion',
      priority,
    });
    
    console.log(`Selected model: ${model.id} (${reason})`);
    
    // 2. 消费积分
    const creditResult = await consumeModelCredits(
      session.user.id,
      model.id,
      'AI Text Generation'
    );
    
    if (!creditResult.success) {
      return NextResponse.json(
        { error: creditResult.error },
        { status: 402 }
      );
    }
    
    // 3. 调用 AI（带降级）
    const result = await resilientGenerate({
      modelId: model.id,
      prompt,
      userId: session.user.id,
      onDegrade: (oldModel, newModel, reason) => {
        console.log(
          `Model degraded: ${oldModel} -> ${newModel} (${reason})`
        );
        
        // 记录降级事件
        logApiUsage({
          userId: session.user.id,
          action: 'model_degradation',
          resource: 'ai_generation',
          metadata: {
            oldModel,
            newModel,
            reason,
          },
        });
      },
    });
    
    // 4. 记录使用
    await logApiUsage({
      userId: session.user.id,
      action: 'ai_generation',
      resource: 'text',
      metadata: {
        modelUsed: result.modelUsed,
        degraded: result.degraded,
        attempts: result.attempts,
      },
    });
    
    return NextResponse.json({
      success: true,
      text: result.text,
      metadata: {
        modelUsed: result.modelUsed,
        degraded: result.degraded,
        attempts: result.attempts,
      },
    });
    
  } catch (error) {
    console.error('AI generation error:', error);
    
    return NextResponse.json(
      { 
        error: 'AI generation failed',
        details: error.message,
      },
      { status: 500 }
    );
  }
}
```

### 2. Server Action 实现

```typescript
// src/actions/generate-text.ts
'use server';

import { userActionClient } from '@/lib/safe-action';
import { z } from 'zod';
import { resilientGenerate } from '@/lib/ai/resilient-generate';
import { selectBestModel } from '@/lib/ai/model-selector';

const schema = z.object({
  prompt: z.string().min(1).max(10000),
  preferredModel: z.string().optional(),
  priority: z.enum(['quality', 'speed', 'cost']).default('quality'),
});

export const generateTextAction = userActionClient
  .schema(schema)
  .action(async ({ parsedInput, ctx }) => {
    try {
      // 选择模型
      const { model } = await selectBestModel({
        userId: ctx.user.id,
        preferredModel: parsedInput.preferredModel,
        task: 'completion',
        priority: parsedInput.priority,
      });
      
      // 生成文本（带降级）
      const result = await resilientGenerate({
        modelId: model.id,
        prompt: parsedInput.prompt,
        userId: ctx.user.id,
      });
      
      return {
        success: true,
        data: {
          text: result.text,
          modelUsed: result.modelUsed,
          degraded: result.degraded,
        },
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
      };
    }
  });
```

## 五、前端实现

### 1. 模型选择器组件

```typescript
// src/components/ai/model-selector.tsx
'use client';

import { useState, useEffect } from 'react';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { modelConfigs } from '@/config/ai-models';

interface ModelSelectorProps {
  value: string;
  onChange: (value: string) => void;
  userPlan: 'free' | 'pro' | 'lifetime';
  creditBalance: number;
}

export function ModelSelector({ 
  value, 
  onChange, 
  userPlan,
  creditBalance 
}: ModelSelectorProps) {
  const [availableModels, setAvailableModels] = useState<string[]>([]);
  
  useEffect(() => {
    // 过滤可用模型
    const planHierarchy = ['free', 'pro', 'lifetime'];
    const userPlanLevel = planHierarchy.indexOf(userPlan);
    
    const available = Object.values(modelConfigs)
      .filter(model => {
        if (!model.availability.enabled) return false;
        
        const requiredPlanLevel = planHierarchy.indexOf(
          model.availability.requiredPlan
        );
        
        if (userPlanLevel < requiredPlanLevel) return false;
        if (creditBalance < model.cost.credits) return false;
        
        return true;
      })
      .map(m => m.id);
    
    setAvailableModels(available);
  }, [userPlan, creditBalance]);
  
  return (
    <div className="space-y-2">
      <label className="text-sm font-medium">AI Model</label>
      <Select value={value} onValueChange={onChange}>
        <SelectTrigger>
          <SelectValue placeholder="Select a model" />
        </SelectTrigger>
        <SelectContent>
          {Object.values(modelConfigs).map(model => {
            const isAvailable = availableModels.includes(model.id);
            const isAffordable = creditBalance >= model.cost.credits;
            
            return (
              <SelectItem
                key={model.id}
                value={model.id}
                disabled={!isAvailable}
              >
                <div className="flex items-center justify-between w-full">
                  <span>{model.name}</span>
                  <div className="flex items-center gap-2">
                    <Badge variant={
                      model.tier.tier === 'premium' ? 'default' :
                      model.tier.tier === 'standard' ? 'secondary' :
                      'outline'
                    }>
                      {model.tier.tier}
                    </Badge>
                    <span className="text-xs text-muted-foreground">
                      {model.cost.credits} credits
                    </span>
                    {!isAffordable && (
                      <Badge variant="destructive">
                        Insufficient credits
                      </Badge>
                    )}
                  </div>
                </div>
              </SelectItem>
            );
          })}
        </SelectContent>
      </Select>
    </div>
  );
}
```

### 2. 降级通知组件

```typescript
// src/components/ai/degradation-notice.tsx
'use client';

import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { AlertTriangle } from 'lucide-react';
import { modelConfigs } from '@/config/ai-models';

interface DegradationNoticeProps {
  originalModel: string;
  usedModel: string;
  reason: string;
}

export function DegradationNotice({ 
  originalModel, 
  usedModel, 
  reason 
}: DegradationNoticeProps) {
  const original = modelConfigs[originalModel];
  const used = modelConfigs[usedModel];
  
  if (!original || !used || originalModel === usedModel) {
    return null;
  }
  
  return (
    <Alert variant="warning">
      <AlertTriangle className="h-4 w-4" />
      <AlertTitle>Model Degraded</AlertTitle>
      <AlertDescription>
        We switched from <strong>{original.name}</strong> to{' '}
        <strong>{used.name}</strong> due to {reason}.
        {used.cost.credits < original.cost.credits && (
          <span className="block mt-1 text-sm">
            You saved {original.cost.credits - used.cost.credits} credits.
          </span>
        )}
      </AlertDescription>
    </Alert>
  );
}
```

### 3. AI 生成器组件

```typescript
// src/components/ai/text-generator.tsx
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { ModelSelector } from './model-selector';
import { DegradationNotice } from './degradation-notice';
import { generateTextAction } from '@/actions/generate-text';
import { useCurrentUser } from '@/hooks/use-current-user';
import { useCreditBalance } from '@/hooks/use-credits';

export function TextGenerator() {
  const { user } = useCurrentUser();
  const { data: creditBalance } = useCreditBalance();
  
  const [prompt, setPrompt] = useState('');
  const [selectedModel, setSelectedModel] = useState('gpt-3.5-turbo');
  const [priority, setPriority] = useState<'quality' | 'speed' | 'cost'>('quality');
  const [result, setResult] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(false);
  
  const handleGenerate = async () => {
    setIsLoading(true);
    setResult(null);
    
    try {
      const response = await generateTextAction({
        prompt,
        preferredModel: selectedModel,
        priority,
      });
      
      if (response?.data?.success) {
        setResult(response.data.data);
      } else {
        console.error('Generation failed:', response?.data?.error);
      }
    } catch (error) {
      console.error('Error:', error);
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <div className="space-y-4">
      {/* 模型选择 */}
      <ModelSelector
        value={selectedModel}
        onChange={setSelectedModel}
        userPlan={user?.plan || 'free'}
        creditBalance={creditBalance?.balance || 0}
      />
      
      {/* 优先级选择 */}
      <div className="space-y-2">
        <label className="text-sm font-medium">Priority</label>
        <div className="flex gap-2">
          {(['quality', 'speed', 'cost'] as const).map(p => (
            <Button
              key={p}
              variant={priority === p ? 'default' : 'outline'}
              onClick={() => setPriority(p)}
              size="sm"
            >
              {p.charAt(0).toUpperCase() + p.slice(1)}
            </Button>
          ))}
        </div>
      </div>
      
      {/* 提示词输入 */}
      <Textarea
        value={prompt}
        onChange={(e) => setPrompt(e.target.value)}
        placeholder="Enter your prompt..."
        rows={6}
      />
      
      {/* 生成按钮 */}
      <Button 
        onClick={handleGenerate} 
        disabled={isLoading || !prompt}
        className="w-full"
      >
        {isLoading ? 'Generating...' : 'Generate'}
      </Button>
      
      {/* 降级通知 */}
      {result?.degraded && (
        <DegradationNotice
          originalModel={selectedModel}
          usedModel={result.modelUsed}
          reason="automatic fallback"
        />
      )}
      
      {/* 结果显示 */}
      {result && (
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <label className="text-sm font-medium">Result</label>
            <span className="text-xs text-muted-foreground">
              Model: {modelConfigs[result.modelUsed]?.name}
            </span>
          </div>
          <div className="p-4 bg-muted rounded-lg">
            <p className="whitespace-pre-wrap">{result.text}</p>
          </div>
        </div>
      )}
    </div>
  );
}
```

## 六、状态管理

### 1. 模型状态追踪

```typescript
// src/lib/ai/model-status.ts
import { Redis } from '@upstash/redis';

const redis = Redis.fromEnv();

export interface ModelStatus {
  modelId: string;
  available: boolean;
  lastChecked: number;
  errorRate: number;
  avgResponseTime: number;
  requestCount: number;
}

export class ModelStatusTracker {
  private static readonly STATUS_TTL = 300; // 5分钟
  
  /**
   * 更新模型状态
   */
  static async updateStatus(
    modelId: string,
    success: boolean,
    responseTime: number
  ) {
    const key = `model:status:${modelId}`;
    const status = await this.getStatus(modelId);
    
    const newStatus: ModelStatus = {
      modelId,
      available: success,
      lastChecked: Date.now(),
      errorRate: success 
        ? status.errorRate * 0.9 
        : Math.min(1, status.errorRate + 0.1),
      avgResponseTime: 
        (status.avgResponseTime * 0.8) + (responseTime * 0.2),
      requestCount: status.requestCount + 1,
    };
    
    await redis.setex(
      key,
      this.STATUS_TTL,
      JSON.stringify(newStatus)
    );
  }
  
  /**
   * 获取模型状态
   */
  static async getStatus(modelId: string): Promise<ModelStatus> {
    const key = `model:status:${modelId}`;
    const cached = await redis.get(key);
    
    if (cached) {
      return JSON.parse(cached as string);
    }
    
    return {
      modelId,
      available: true,
      lastChecked: Date.now(),
      errorRate: 0,
      avgResponseTime: 0,
      requestCount: 0,
    };
  }
  
  /**
   * 获取所有模型状态
   */
  static async getAllStatuses(): Promise<ModelStatus[]> {
    const modelIds = Object.keys(modelConfigs);
    const statuses = await Promise.all(
      modelIds.map(id => this.getStatus(id))
    );
    return statuses;
  }
}
```

### 2. 健康检查

```typescript
// src/app/api/ai/health/route.ts
import { NextResponse } from 'next/server';
import { ModelStatusTracker } from '@/lib/ai/model-status';
import { modelConfigs } from '@/config/ai-models';

export async function GET() {
  const statuses = await ModelStatusTracker.getAllStatuses();
  
  const health = statuses.map(status => {
    const config = modelConfigs[status.modelId];
    
    return {
      modelId: status.modelId,
      name: config?.name,
      available: status.available,
      errorRate: status.errorRate,
      avgResponseTime: status.avgResponseTime,
      health: status.errorRate < 0.1 ? 'healthy' : 
              status.errorRate < 0.3 ? 'degraded' : 'unhealthy',
    };
  });
  
  return NextResponse.json({
    timestamp: new Date().toISOString(),
    models: health,
  });
}
```

## 七、监控和告警

### 1. 降级事件记录

```typescript
// src/lib/ai/degradation-logger.ts
import { db } from '@/db';
import { degradationLog } from '@/db/schema';
import { nanoid } from 'nanoid';

export async function logDegradation(data: {
  userId: string;
  originalModel: string;
  degradedModel: string;
  reason: string;
  success: boolean;
  metadata?: Record<string, any>;
}) {
  await db.insert(degradationLog).values({
    id: nanoid(),
    userId: data.userId,
    originalModel: data.originalModel,
    degradedModel: data.degradedModel,
    reason: data.reason,
    success: data.success,
    metadata: data.metadata,
    createdAt: new Date(),
  });
}
```

### 2. 告警系统

```typescript
// src/lib/ai/degradation-alerts.ts
import { sendDiscordNotification } from '@/notification/discord';

export async function alertHighDegradationRate(
  modelId: string,
  rate: number
) {
  if (rate > 0.5) {
    await sendDiscordNotification(
      `⚠️ High degradation rate for ${modelId}: ${(rate * 100).toFixed(1)}%`,
      'warning'
    );
  }
}
```

## 八、最佳实践

### 1. 降级策略

- 优先降级到同提供商的低级模型
- 考虑任务类型选择降级模型
- 保持降级链不超过3层
- 记录所有降级事件

### 2. 成本优化

- 根据任务复杂度选择模型
- 使用缓存减少重复调用
- 实施智能路由
- 监控成本趋势

### 3. 用户体验

- 透明地告知用户降级
- 提供手动选择选项
- 显示预估成本
- 快速失败和重试

## 总结

MkSaaS 的模型降级系统提供：

1. **自动降级**: 智能检测和切换
2. **多层策略**: 灵活的降级链
3. **成本控制**: 基于积分的使用管理
4. **状态追踪**: 实时模型健康监控
5. **用户控制**: 前端模型选择和优先级
6. **透明通知**: 清晰的降级信息
7. **监控告警**: 完整的事件记录

通过这些机制，确保 AI 服务的高可用性和成本效益。
