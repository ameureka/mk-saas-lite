# 问题8：数据库是使用什么方式以及模式设计的，如何设计数据库？

## 概述

MkSaaS 使用 **PostgreSQL** 作为主数据库，通过 **Drizzle ORM** 进行数据库操作，采用 **代码优先（Code-First）** 的 Schema 设计模式。

## 技术栈

### 核心技术

1. **PostgreSQL**: 关系型数据库
   - 强大的 ACID 特性
   - 丰富的数据类型
   - 优秀的性能和扩展性
   - 支持 JSON/JSONB

2. **Drizzle ORM**: TypeScript ORM
   - 类型安全
   - 零运行时开销
   - SQL-like 语法
   - 自动迁移生成

3. **Drizzle Kit**: 迁移工具
   - 自动生成迁移文件
   - Schema 推送
   - Studio 可视化工具

## 数据库配置

### 1. Drizzle 配置文件

```typescript
// drizzle.config.ts
import { loadEnvConfig } from '@next/env';
import { defineConfig } from 'drizzle-kit';

// 加载 Next.js 环境变量
const projectDir = process.cwd();
loadEnvConfig(projectDir);

export default defineConfig({
  out: './src/db/migrations',      // 迁移文件输出目录
  schema: './src/db/schema.ts',    // Schema 定义文件
  dialect: 'postgresql',            // 数据库方言
  dbCredentials: {
    url: process.env.DATABASE_URL!, // 数据库连接字符串
  },
});
```

### 2. 数据库连接

```typescript
// src/db/index.ts
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from './schema';

// 创建 PostgreSQL 客户端
const client = postgres(process.env.DATABASE_URL!, {
  max: 10,                    // 最大连接数
  idle_timeout: 20,           // 空闲超时（秒）
  connect_timeout: 10,        // 连接超时（秒）
});

// 创建 Drizzle 实例
export const db = drizzle(client, {
  schema,
  logger: process.env.NODE_ENV === 'development', // 开发环境启用日志
});

// 获取数据库实例（支持异步初始化）
export async function getDb() {
  return db;
}
```

## 数据库 Schema 设计

### 完整 Schema 结构

```typescript
// src/db/schema.ts
import { 
  boolean, 
  integer, 
  pgTable, 
  text, 
  timestamp, 
  index 
} from "drizzle-orm/pg-core";

// ============================================
// 1. 用户表 (user)
// ============================================
export const user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text('name').notNull(),
  email: text('email').notNull().unique(),
  emailVerified: boolean('email_verified').notNull(),
  image: text('image'),
  createdAt: timestamp('created_at').notNull(),
  updatedAt: timestamp('updated_at').notNull(),
  
  // 角色和权限
  role: text('role'),                    // admin | user | null
  
  // 封禁管理
  banned: boolean('banned'),
  banReason: text('ban_reason'),
  banExpires: timestamp('ban_expires'),
  
  // 支付相关
  customerId: text('customer_id'),       // Stripe Customer ID
}, (table) => ({
  // 索引定义
  userIdIdx: index("user_id_idx").on(table.id),
  userCustomerIdIdx: index("user_customer_id_idx").on(table.customerId),
  userRoleIdx: index("user_role_idx").on(table.role),
}));

// ============================================
// 2. 会话表 (session)
// ============================================
export const session = pgTable("session", {
  id: text("id").primaryKey(),
  expiresAt: timestamp('expires_at').notNull(),
  token: text('token').notNull().unique(),
  createdAt: timestamp('created_at').notNull(),
  updatedAt: timestamp('updated_at').notNull(),
  
  // 会话信息
  ipAddress: text('ip_address'),
  userAgent: text('user_agent'),
  
  // 关联用户
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  
  // 管理员模拟登录
  impersonatedBy: text('impersonated_by'),
}, (table) => ({
  sessionTokenIdx: index("session_token_idx").on(table.token),
  sessionUserIdIdx: index("session_user_id_idx").on(table.userId),
}));

// ============================================
// 3. 账户表 (account)
// ============================================
export const account = pgTable("account", {
  id: text("id").primaryKey(),
  accountId: text('account_id').notNull(),
  providerId: text('provider_id').notNull(),  // github | google | email
  
  // 关联用户
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  
  // OAuth Token
  accessToken: text('access_token'),
  refreshToken: text('refresh_token'),
  idToken: text('id_token'),
  accessTokenExpiresAt: timestamp('access_token_expires_at'),
  refreshTokenExpiresAt: timestamp('refresh_token_expires_at'),
  scope: text('scope'),
  
  // 密码（仅用于邮箱密码登录）
  password: text('password'),
  
  createdAt: timestamp('created_at').notNull(),
  updatedAt: timestamp('updated_at').notNull()
}, (table) => ({
  accountUserIdIdx: index("account_user_id_idx").on(table.userId),
  accountAccountIdIdx: index("account_account_id_idx").on(table.accountId),
  accountProviderIdIdx: index("account_provider_id_idx").on(table.providerId),
}));

// ============================================
// 4. 验证表 (verification)
// ============================================
export const verification = pgTable("verification", {
  id: text("id").primaryKey(),
  identifier: text('identifier').notNull(),  // 邮箱或手机号
  value: text('value').notNull(),            // 验证码或 token
  expiresAt: timestamp('expires_at').notNull(),
  createdAt: timestamp('created_at'),
  updatedAt: timestamp('updated_at')
});

// ============================================
// 5. 支付表 (payment)
// ============================================
export const payment = pgTable("payment", {
  id: text("id").primaryKey(),
  priceId: text('price_id').notNull(),
  type: text('type').notNull(),              // SUBSCRIPTION | ONE_TIME
  scene: text('scene'),                       // lifetime | credit | subscription
  interval: text('interval'),                 // month | year
  
  // 关联用户
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  
  // Stripe 相关
  customerId: text('customer_id').notNull(),
  subscriptionId: text('subscription_id'),
  sessionId: text('session_id'),
  invoiceId: text('invoice_id').unique(),     // 唯一约束，防止重复处理
  
  // 支付状态
  status: text('status').notNull(),           // active | canceled | past_due
  paid: boolean('paid').notNull().default(false),
  
  // 订阅周期
  periodStart: timestamp('period_start'),
  periodEnd: timestamp('period_end'),
  cancelAtPeriodEnd: boolean('cancel_at_period_end'),
  
  // 试用期
  trialStart: timestamp('trial_start'),
  trialEnd: timestamp('trial_end'),
  
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
}, (table) => ({
  paymentTypeIdx: index("payment_type_idx").on(table.type),
  paymentSceneIdx: index("payment_scene_idx").on(table.scene),
  paymentPriceIdIdx: index("payment_price_id_idx").on(table.priceId),
  paymentUserIdIdx: index("payment_user_id_idx").on(table.userId),
  paymentCustomerIdIdx: index("payment_customer_id_idx").on(table.customerId),
  paymentStatusIdx: index("payment_status_idx").on(table.status),
  paymentPaidIdx: index("payment_paid_idx").on(table.paid),
  paymentSubscriptionIdIdx: index("payment_subscription_id_idx").on(table.subscriptionId),
  paymentSessionIdIdx: index("payment_session_id_idx").on(table.sessionId),
  paymentInvoiceIdIdx: index("payment_invoice_id_idx").on(table.invoiceId),
}));

// ============================================
// 6. 用户积分表 (user_credit)
// ============================================
export const userCredit = pgTable("user_credit", {
  id: text("id").primaryKey(),
  
  // 关联用户
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  
  // 积分余额
  currentCredits: integer("current_credits").notNull().default(0),
  
  // 已废弃字段
  lastRefreshAt: timestamp("last_refresh_at"),
  
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
}, (table) => ({
  userCreditUserIdIdx: index("user_credit_user_id_idx").on(table.userId),
}));

// ============================================
// 7. 积分交易表 (credit_transaction)
// ============================================
export const creditTransaction = pgTable("credit_transaction", {
  id: text("id").primaryKey(),
  
  // 关联用户
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  
  // 交易信息
  type: text("type").notNull(),              // purchase | consume | gift | refund
  description: text("description"),
  amount: integer("amount").notNull(),       // 正数为增加，负数为减少
  remainingAmount: integer("remaining_amount"),
  
  // 关联支付
  paymentId: text("payment_id"),             // 实际存储的是 invoiceId
  
  // 过期管理
  expirationDate: timestamp("expiration_date"),
  expirationDateProcessedAt: timestamp("expiration_date_processed_at"),
  
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
}, (table) => ({
  creditTransactionUserIdIdx: index("credit_transaction_user_id_idx").on(table.userId),
  creditTransactionTypeIdx: index("credit_transaction_type_idx").on(table.type),
}));
```

## 数据库设计原则

### 1. 命名规范

- **表名**: 使用单数形式，snake_case（如 `user`, `credit_transaction`）
- **字段名**: snake_case（如 `user_id`, `created_at`）
- **索引名**: `{table}_{column}_idx`（如 `user_id_idx`）
- **外键**: 明确命名关联关系

### 2. 主键设计

使用文本类型的 UUID 或 NanoID:

```typescript
import { nanoid } from 'nanoid';

// 创建记录时生成 ID
const newUser = await db.insert(user).values({
  id: nanoid(),
  name: 'John Doe',
  email: 'john@example.com',
  // ...
});
```

### 3. 时间戳字段

每个表都包含 `createdAt` 和 `updatedAt`:

```typescript
createdAt: timestamp("created_at").notNull().defaultNow(),
updatedAt: timestamp("updated_at").notNull().defaultNow(),
```

### 4. 外键约束

使用级联删除确保数据一致性:

```typescript
userId: text('user_id')
  .notNull()
  .references(() => user.id, { onDelete: 'cascade' }),
```

### 5. 索引策略

为常用查询字段添加索引:

```typescript
(table) => ({
  userIdIdx: index("user_id_idx").on(table.userId),
  statusIdx: index("status_idx").on(table.status),
  createdAtIdx: index("created_at_idx").on(table.createdAt),
})
```

### 6. 唯一约束

防止重复数据:

```typescript
email: text('email').notNull().unique(),
invoiceId: text('invoice_id').unique(),
```

## 数据库操作

### 1. 查询操作

```typescript
import { db } from '@/db';
import { user, payment } from '@/db/schema';
import { eq, and, desc, gte } from 'drizzle-orm';

// 简单查询
const users = await db.select().from(user);

// 条件查询
const activeUser = await db
  .select()
  .from(user)
  .where(eq(user.id, userId))
  .limit(1);

// 复杂查询
const activePayments = await db
  .select()
  .from(payment)
  .where(
    and(
      eq(payment.userId, userId),
      eq(payment.status, 'active'),
      gte(payment.periodEnd, new Date())
    )
  )
  .orderBy(desc(payment.createdAt));

// JOIN 查询
const usersWithPayments = await db
  .select({
    user: user,
    payment: payment,
  })
  .from(user)
  .leftJoin(payment, eq(user.id, payment.userId));
```

### 2. 插入操作

```typescript
// 单条插入
const newUser = await db.insert(user).values({
  id: nanoid(),
  name: 'John Doe',
  email: 'john@example.com',
  emailVerified: false,
  createdAt: new Date(),
  updatedAt: new Date(),
}).returning();

// 批量插入
const newUsers = await db.insert(user).values([
  { id: nanoid(), name: 'User 1', email: 'user1@example.com', /* ... */ },
  { id: nanoid(), name: 'User 2', email: 'user2@example.com', /* ... */ },
]).returning();

// 冲突处理（Upsert）
await db.insert(payment).values({
  id: nanoid(),
  userId,
  invoiceId: 'inv_123',
  // ...
}).onConflictDoUpdate({
  target: payment.invoiceId,
  set: {
    status: 'active',
    paid: true,
    updatedAt: new Date(),
  },
});
```

### 3. 更新操作

```typescript
// 更新单条记录
await db
  .update(user)
  .set({
    name: 'New Name',
    updatedAt: new Date(),
  })
  .where(eq(user.id, userId));

// 条件更新
await db
  .update(payment)
  .set({
    status: 'canceled',
    cancelAtPeriodEnd: true,
    updatedAt: new Date(),
  })
  .where(
    and(
      eq(payment.userId, userId),
      eq(payment.status, 'active')
    )
  );
```

### 4. 删除操作

```typescript
// 删除单条记录
await db
  .delete(user)
  .where(eq(user.id, userId));

// 条件删除
await db
  .delete(session)
  .where(
    and(
      eq(session.userId, userId),
      lt(session.expiresAt, new Date())
    )
  );
```

### 5. 事务操作

```typescript
await db.transaction(async (tx) => {
  // 扣除积分
  await tx
    .update(userCredit)
    .set({
      currentCredits: sql`${userCredit.currentCredits} - ${amount}`,
      updatedAt: new Date(),
    })
    .where(eq(userCredit.userId, userId));
  
  // 创建交易记录
  await tx.insert(creditTransaction).values({
    id: nanoid(),
    userId,
    type: 'consume',
    amount: -amount,
    description: 'AI generation',
    createdAt: new Date(),
    updatedAt: new Date(),
  });
});
```

## 数据库迁移

### 1. 生成迁移文件

```bash
# 根据 schema.ts 生成迁移文件
pnpm db:generate
```

这会在 `src/db/migrations/` 生成 SQL 文件。

### 2. 应用迁移

```bash
# 应用迁移到数据库
pnpm db:migrate
```

### 3. 直接推送 Schema

```bash
# 直接将 schema 推送到数据库（开发环境）
pnpm db:push
```

### 4. 可视化管理

```bash
# 启动 Drizzle Studio
pnpm db:studio
```

访问 `https://local.drizzle.studio` 进行可视化管理。

## 数据库类型定义

```typescript
// src/db/types.ts
import type { InferSelectModel, InferInsertModel } from 'drizzle-orm';
import * as schema from './schema';

// Select 类型（查询结果）
export type User = InferSelectModel<typeof schema.user>;
export type Session = InferSelectModel<typeof schema.session>;
export type Account = InferSelectModel<typeof schema.account>;
export type Payment = InferSelectModel<typeof schema.payment>;
export type UserCredit = InferSelectModel<typeof schema.userCredit>;
export type CreditTransaction = InferSelectModel<typeof schema.creditTransaction>;

// Insert 类型（插入数据）
export type InsertUser = InferInsertModel<typeof schema.user>;
export type InsertPayment = InferInsertModel<typeof schema.payment>;
export type InsertCreditTransaction = InferInsertModel<typeof schema.creditTransaction>;
```

## 环境变量

```env
# PostgreSQL 数据库连接
DATABASE_URL=postgresql://user:password@host:5432/database

# 或使用连接池（推荐生产环境）
DATABASE_URL=postgresql://user:password@host:5432/database?pgbouncer=true
```

## 数据库提供商

### 1. Vercel Postgres
- 无服务器 PostgreSQL
- 自动扩展
- 与 Vercel 深度集成

### 2. Neon
- Serverless PostgreSQL
- 分支功能
- 免费额度

### 3. Supabase
- 开源 Firebase 替代品
- 实时功能
- 内置认证

### 4. Railway
- 简单部署
- 自动备份
- 合理定价

### 5. 自建 PostgreSQL
- 完全控制
- 成本可控
- 需要运维

## 性能优化

### 1. 连接池配置

```typescript
const client = postgres(process.env.DATABASE_URL!, {
  max: 10,                    // 最大连接数
  idle_timeout: 20,           // 空闲超时
  connect_timeout: 10,        // 连接超时
});
```

### 2. 查询优化

```typescript
// 使用索引字段查询
await db.select().from(user).where(eq(user.id, userId));

// 限制返回字段
await db.select({
  id: user.id,
  name: user.name,
  email: user.email,
}).from(user);

// 使用分页
await db
  .select()
  .from(user)
  .limit(10)
  .offset(page * 10);
```

### 3. 批量操作

```typescript
// 批量插入
await db.insert(user).values(users);

// 批量更新（使用事务）
await db.transaction(async (tx) => {
  for (const u of users) {
    await tx.update(user).set(u).where(eq(user.id, u.id));
  }
});
```

### 4. 预加载关联数据

```typescript
// 使用 JOIN 而不是多次查询
const result = await db
  .select()
  .from(user)
  .leftJoin(payment, eq(user.id, payment.userId))
  .where(eq(user.id, userId));
```

## 备份和恢复

### 1. 自动备份

大多数托管服务提供自动备份功能。

### 2. 手动备份

```bash
# 导出数据库
pg_dump -h host -U user -d database > backup.sql

# 恢复数据库
psql -h host -U user -d database < backup.sql
```

### 3. 迁移脚本

在 `scripts/` 目录创建数据迁移脚本:

```typescript
// scripts/migrate-data.ts
import { db } from '@/db';
import { user } from '@/db/schema';

async function migrateData() {
  // 执行数据迁移逻辑
  const users = await db.select().from(user);
  
  for (const u of users) {
    // 更新数据
    await db.update(user).set({
      // 新字段
    }).where(eq(user.id, u.id));
  }
}

migrateData();
```

## 总结

MkSaaS 的数据库设计遵循以下原则：

1. **类型安全**: 使用 Drizzle ORM 确保类型安全
2. **代码优先**: Schema 定义在代码中，自动生成迁移
3. **索引优化**: 为常用查询添加索引
4. **外键约束**: 确保数据一致性
5. **事务支持**: 关键操作使用事务
6. **迁移管理**: 版本化的数据库迁移
7. **性能优化**: 连接池、查询优化、批量操作

通过这种设计，可以构建可扩展、高性能、易维护的数据库系统。
