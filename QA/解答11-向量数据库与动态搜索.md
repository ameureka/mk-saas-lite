# 问题11：有没有动态的搜索的能力以及这些能力如何与向量数据库结合的，使用什么向量数据库？

## 概述

MkSaaS 集成了 **Orama** 作为全文搜索引擎，并支持向量搜索功能。系统可以与多种向量数据库集成，实现语义搜索和 RAG（检索增强生成）功能。

## 搜索技术栈

### 已集成的搜索工具

从 `package.json` 可以看到：

```json
{
  "dependencies": {
    "@orama/orama": "^3.1.4",          // 全文搜索引擎
    "@orama/tokenizers": "^3.1.4",     // 分词器
    "@mendable/firecrawl-js": "^1.29.1"  // 网页内容爬取
  }
}
```

## 1. Orama 全文搜索

### 特性

- **快速**: 毫秒级搜索响应
- **轻量**: 无需外部服务
- **灵活**: 支持多种数据类型
- **向量搜索**: 支持语义搜索
- **实时**: 即时索引更新
- **多语言**: 支持中文分词

### 基础实现

#### 创建搜索索引

```typescript
// src/lib/search/orama-search.ts
import { create, insert, search, remove } from '@orama/orama';

// 创建搜索数据库
export async function createSearchDB() {
  const db = await create({
    schema: {
      id: 'string',
      title: 'string',
      content: 'string',
      category: 'string',
      tags: 'string[]',
      author: 'string',
      publishedAt: 'number',
      url: 'string',
    },
    components: {
      tokenizer: {
        // 使用中文分词器
        language: 'chinese',
      },
    },
  });
  
  return db;
}

// 添加文档到索引
export async function addDocument(db, document) {
  await insert(db, {
    id: document.id,
    title: document.title,
    content: document.content,
    category: document.category,
    tags: document.tags,
    author: document.author,
    publishedAt: new Date(document.publishedAt).getTime(),
    url: document.url,
  });
}

// 批量添加文档
export async function addDocuments(db, documents) {
  for (const doc of documents) {
    await addDocument(db, doc);
  }
}

// 搜索文档
export async function searchDocuments(db, query, options = {}) {
  const results = await search(db, {
    term: query,
    properties: ['title', 'content', 'tags'],
    limit: options.limit || 10,
    offset: options.offset || 0,
    boost: {
      title: 2,      // 标题权重更高
      content: 1,
      tags: 1.5,
    },
    tolerance: 1,    // 容错度
  });
  
  return results;
}

// 删除文档
export async function removeDocument(db, id) {
  await remove(db, id);
}
```

### 高级搜索功能

#### 1. 分面搜索（Faceted Search）

```typescript
import { create, insert, search } from '@orama/orama';

export async function facetedSearch(db, query) {
  const results = await search(db, {
    term: query,
    properties: ['title', 'content'],
    facets: {
      category: {
        limit: 10,
      },
      author: {
        limit: 5,
      },
      tags: {
        limit: 20,
      },
    },
  });
  
  return {
    hits: results.hits,
    facets: results.facets,
    count: results.count,
  };
}
```

#### 2. 过滤搜索

```typescript
export async function filteredSearch(db, query, filters) {
  const results = await search(db, {
    term: query,
    properties: ['title', 'content'],
    where: {
      category: filters.category,
      author: filters.author,
      publishedAt: {
        gte: filters.startDate,
        lte: filters.endDate,
      },
    },
    limit: 10,
  });
  
  return results;
}
```

#### 3. 排序搜索

```typescript
export async function sortedSearch(db, query, sortBy = 'publishedAt', order = 'desc') {
  const results = await search(db, {
    term: query,
    properties: ['title', 'content'],
    sortBy: {
      property: sortBy,
      order: order,
    },
    limit: 10,
  });
  
  return results;
}
```

### API 路由实现

```typescript
// src/app/api/search/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { searchDocuments, createSearchDB, addDocuments } from '@/lib/search/orama-search';
import { blog } from '@/.source';

// 全局搜索数据库实例
let searchDB: any = null;

// 初始化搜索数据库
async function initSearchDB() {
  if (!searchDB) {
    searchDB = await createSearchDB();
    
    // 索引所有博客文章
    const posts = blog.getPages();
    await addDocuments(searchDB, posts.map(post => ({
      id: post.url,
      title: post.data.title,
      content: post.data.description || '',
      category: post.data.categories?.[0] || '',
      tags: post.data.categories || [],
      author: post.data.author || '',
      publishedAt: post.data.date,
      url: post.url,
    })));
  }
  
  return searchDB;
}

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const query = searchParams.get('q');
  const limit = parseInt(searchParams.get('limit') || '10');
  const offset = parseInt(searchParams.get('offset') || '0');
  
  if (!query) {
    return NextResponse.json(
      { error: 'Query parameter is required' },
      { status: 400 }
    );
  }
  
  try {
    const db = await initSearchDB();
    const results = await searchDocuments(db, query, { limit, offset });
    
    return NextResponse.json({
      success: true,
      results: results.hits.map(hit => ({
        id: hit.id,
        document: hit.document,
        score: hit.score,
      })),
      count: results.count,
      elapsed: results.elapsed,
    });
  } catch (error) {
    console.error('Search error:', error);
    return NextResponse.json(
      { error: 'Search failed' },
      { status: 500 }
    );
  }
}
```

### 前端搜索组件

```typescript
// src/components/search/search-dialog.tsx
'use client';

import { useState, useEffect } from 'react';
import { useDebounce } from '@/hooks/use-debounce';
import { Dialog, DialogContent } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Loader2 } from 'lucide-react';
import Link from 'next/link';

export function SearchDialog({ open, onOpenChange }) {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  
  const debouncedQuery = useDebounce(query, 300);
  
  useEffect(() => {
    if (debouncedQuery) {
      searchDocuments(debouncedQuery);
    } else {
      setResults([]);
    }
  }, [debouncedQuery]);
  
  const searchDocuments = async (q: string) => {
    setIsLoading(true);
    
    try {
      const response = await fetch(`/api/search?q=${encodeURIComponent(q)}&limit=10`);
      const data = await response.json();
      
      if (data.success) {
        setResults(data.results);
      }
    } catch (error) {
      console.error('Search error:', error);
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl">
        <div className="space-y-4">
          <div className="relative">
            <Input
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              placeholder="搜索文章、文档..."
              className="pr-10"
              autoFocus
            />
            {isLoading && (
              <Loader2 className="absolute right-3 top-3 h-4 w-4 animate-spin" />
            )}
          </div>
          
          <div className="max-h-[400px] overflow-y-auto space-y-2">
            {results.length === 0 && query && !isLoading && (
              <p className="text-center text-muted-foreground py-8">
                没有找到相关结果
              </p>
            )}
            
            {results.map((result) => (
              <Link
                key={result.id}
                href={result.document.url}
                className="block p-4 rounded-lg hover:bg-muted transition-colors"
                onClick={() => onOpenChange(false)}
              >
                <h3 className="font-semibold">{result.document.title}</h3>
                <p className="text-sm text-muted-foreground line-clamp-2">
                  {result.document.content}
                </p>
                <div className="flex items-center gap-2 mt-2 text-xs text-muted-foreground">
                  <span>{result.document.category}</span>
                  <span>•</span>
                  <span>相关度: {(result.score * 100).toFixed(0)}%</span>
                </div>
              </Link>
            ))}
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

## 2. 向量搜索集成

### 支持的向量数据库

#### 1. Pinecone（推荐）

**特点**:
- 完全托管
- 高性能
- 易于扩展
- 免费额度

**安装**:
```bash
pnpm add @pinecone-database/pinecone
```

**实现**:
```typescript
// src/lib/vector/pinecone.ts
import { Pinecone } from '@pinecone-database/pinecone';
import { openai } from '@ai-sdk/openai';
import { embed, embedMany } from 'ai';

const pinecone = new Pinecone({
  apiKey: process.env.PINECONE_API_KEY!,
});

const index = pinecone.index('blog-posts');

// 生成单个嵌入向量
export async function generateEmbedding(text: string) {
  const { embedding } = await embed({
    model: openai.embedding('text-embedding-3-small'),
    value: text,
  });
  
  return embedding;
}

// 批量生成嵌入向量
export async function generateEmbeddings(texts: string[]) {
  const { embeddings } = await embedMany({
    model: openai.embedding('text-embedding-3-small'),
    values: texts,
  });
  
  return embeddings;
}

// 存储向量
export async function upsertVectors(documents: Array<{
  id: string;
  text: string;
  metadata: any;
}>) {
  const texts = documents.map(doc => doc.text);
  const embeddings = await generateEmbeddings(texts);
  
  const vectors = documents.map((doc, i) => ({
    id: doc.id,
    values: embeddings[i],
    metadata: {
      text: doc.text,
      ...doc.metadata,
    },
  }));
  
  await index.upsert(vectors);
}

// 向量搜索
export async function vectorSearch(query: string, topK: number = 5, filter?: any) {
  const queryEmbedding = await generateEmbedding(query);
  
  const results = await index.query({
    vector: queryEmbedding,
    topK,
    includeMetadata: true,
    filter,
  });
  
  return results.matches;
}

// 删除向量
export async function deleteVectors(ids: string[]) {
  await index.deleteMany(ids);
}
```

#### 2. Supabase Vector（PostgreSQL + pgvector）

**特点**:
- 开源
- 与 PostgreSQL 集成
- 成本低
- 易于自建

**实现**:
```typescript
// src/lib/vector/supabase-vector.ts
import { createClient } from '@supabase/supabase-js';
import { generateEmbedding } from './pinecone';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// 创建向量表（运行一次）
export async function createVectorTable() {
  const { error } = await supabase.rpc('create_vector_table', {
    table_name: 'documents',
    vector_dimension: 1536,
  });
  
  if (error) throw error;
}

// 存储向量
export async function storeVector(document: {
  id: string;
  content: string;
  metadata: any;
}) {
  const embedding = await generateEmbedding(document.content);
  
  const { error } = await supabase
    .from('documents')
    .upsert({
      id: document.id,
      content: document.content,
      embedding,
      metadata: document.metadata,
    });
  
  if (error) throw error;
}

// 向量搜索
export async function searchVectors(query: string, limit: number = 5) {
  const queryEmbedding = await generateEmbedding(query);
  
  const { data, error } = await supabase.rpc('match_documents', {
    query_embedding: queryEmbedding,
    match_threshold: 0.7,
    match_count: limit,
  });
  
  if (error) throw error;
  
  return data;
}
```

#### 3. Qdrant

**特点**:
- 高性能
- 开源
- 支持过滤
- 可自建或托管

**实现**:
```typescript
// src/lib/vector/qdrant.ts
import { QdrantClient } from '@qdrant/js-client-rest';
import { generateEmbedding } from './pinecone';

const client = new QdrantClient({
  url: process.env.QDRANT_URL!,
  apiKey: process.env.QDRANT_API_KEY,
});

const collectionName = 'blog_posts';

// 创建集合
export async function createCollection() {
  await client.createCollection(collectionName, {
    vectors: {
      size: 1536,
      distance: 'Cosine',
    },
  });
}

// 存储向量
export async function upsertPoint(document: {
  id: string;
  text: string;
  metadata: any;
}) {
  const embedding = await generateEmbedding(document.text);
  
  await client.upsert(collectionName, {
    points: [
      {
        id: document.id,
        vector: embedding,
        payload: {
          text: document.text,
          ...document.metadata,
        },
      },
    ],
  });
}

// 向量搜索
export async function searchPoints(query: string, limit: number = 5, filter?: any) {
  const queryEmbedding = await generateEmbedding(query);
  
  const results = await client.search(collectionName, {
    vector: queryEmbedding,
    limit,
    filter,
  });
  
  return results;
}
```

## 3. 混合搜索（Hybrid Search）

### 结合全文搜索和向量搜索

```typescript
// src/lib/search/hybrid-search.ts
import { searchDocuments as oramaSearch } from './orama-search';
import { vectorSearch } from './vector/pinecone';

export async function hybridSearch(query: string, options = {}) {
  const {
    limit = 10,
    fullTextWeight = 0.5,
    vectorWeight = 0.5,
  } = options;
  
  // 并行执行全文搜索和向量搜索
  const [fullTextResults, vectorResults] = await Promise.all([
    oramaSearch(db, query, { limit: limit * 2 }),
    vectorSearch(query, limit * 2),
  ]);
  
  // 合并结果
  const combinedResults = new Map();
  
  // 添加全文搜索结果
  fullTextResults.hits.forEach((hit, index) => {
    const score = (1 - index / fullTextResults.hits.length) * fullTextWeight;
    combinedResults.set(hit.id, {
      document: hit.document,
      score,
    });
  });
  
  // 添加向量搜索结果
  vectorResults.forEach((match, index) => {
    const score = match.score * vectorWeight;
    const existing = combinedResults.get(match.id);
    
    if (existing) {
      existing.score += score;
    } else {
      combinedResults.set(match.id, {
        document: match.metadata,
        score,
      });
    }
  });
  
  // 排序并返回
  const sorted = Array.from(combinedResults.values())
    .sort((a, b) => b.score - a.score)
    .slice(0, limit);
  
  return sorted;
}
```

### API 路由

```typescript
// src/app/api/search/hybrid/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { hybridSearch } from '@/lib/search/hybrid-search';

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const query = searchParams.get('q');
  const limit = parseInt(searchParams.get('limit') || '10');
  
  if (!query) {
    return NextResponse.json(
      { error: 'Query parameter is required' },
      { status: 400 }
    );
  }
  
  try {
    const results = await hybridSearch(query, { limit });
    
    return NextResponse.json({
      success: true,
      results,
    });
  } catch (error) {
    console.error('Hybrid search error:', error);
    return NextResponse.json(
      { error: 'Search failed' },
      { status: 500 }
    );
  }
}
```

## 4. 实时搜索建议

### 自动完成功能

```typescript
// src/lib/search/autocomplete.ts
import { search } from '@orama/orama';

export async function getAutocompleteSuggestions(db, query: string, limit: number = 5) {
  if (query.length < 2) return [];
  
  const results = await search(db, {
    term: query,
    properties: ['title'],
    limit,
    tolerance: 2,
  });
  
  return results.hits.map(hit => ({
    text: hit.document.title,
    url: hit.document.url,
  }));
}
```

### 前端实现

```typescript
// src/components/search/search-autocomplete.tsx
'use client';

import { useState, useEffect } from 'react';
import { useDebounce } from '@/hooks/use-debounce';
import { Command, CommandInput, CommandList, CommandItem } from '@/components/ui/command';

export function SearchAutocomplete() {
  const [query, setQuery] = useState('');
  const [suggestions, setSuggestions] = useState([]);
  
  const debouncedQuery = useDebounce(query, 200);
  
  useEffect(() => {
    if (debouncedQuery) {
      fetchSuggestions(debouncedQuery);
    } else {
      setSuggestions([]);
    }
  }, [debouncedQuery]);
  
  const fetchSuggestions = async (q: string) => {
    const response = await fetch(`/api/search/autocomplete?q=${encodeURIComponent(q)}`);
    const data = await response.json();
    setSuggestions(data.suggestions || []);
  };
  
  return (
    <Command>
      <CommandInput
        value={query}
        onValueChange={setQuery}
        placeholder="搜索..."
      />
      <CommandList>
        {suggestions.map((suggestion, index) => (
          <CommandItem
            key={index}
            onSelect={() => {
              window.location.href = suggestion.url;
            }}
          >
            {suggestion.text}
          </CommandItem>
        ))}
      </CommandList>
    </Command>
  );
}
```

## 5. 搜索分析

### 记录搜索查询

```typescript
// src/lib/search/analytics.ts
import { db } from '@/db';
import { searchQuery } from '@/db/schema';
import { nanoid } from 'nanoid';

export async function logSearchQuery(query: string, userId?: string, results: number = 0) {
  await db.insert(searchQuery).values({
    id: nanoid(),
    query,
    userId,
    resultsCount: results,
    createdAt: new Date(),
  });
}

// 获取热门搜索
export async function getPopularSearches(limit: number = 10) {
  const results = await db
    .select({
      query: searchQuery.query,
      count: sql`count(*)`,
    })
    .from(searchQuery)
    .groupBy(searchQuery.query)
    .orderBy(desc(sql`count(*)`))
    .limit(limit);
  
  return results;
}
```

## 6. 搜索优化

### 1. 索引优化

```typescript
// 定期重建索引
export async function rebuildSearchIndex() {
  const newDB = await createSearchDB();
  
  // 获取所有文档
  const documents = await getAllDocuments();
  
  // 批量添加
  await addDocuments(newDB, documents);
  
  // 替换旧索引
  searchDB = newDB;
}
```

### 2. 缓存搜索结果

```typescript
import { Redis } from '@upstash/redis';

const redis = Redis.fromEnv();

export async function cachedSearch(query: string) {
  const cacheKey = `search:${query}`;
  
  // 尝试从缓存获取
  const cached = await redis.get(cacheKey);
  if (cached) {
    return cached;
  }
  
  // 执行搜索
  const results = await searchDocuments(db, query);
  
  // 缓存结果（1小时）
  await redis.setex(cacheKey, 3600, results);
  
  return results;
}
```

### 3. 搜索性能监控

```typescript
export async function monitoredSearch(query: string) {
  const startTime = Date.now();
  
  try {
    const results = await searchDocuments(db, query);
    const duration = Date.now() - startTime;
    
    // 记录性能指标
    console.log(`Search completed in ${duration}ms`);
    
    // 如果搜索太慢，记录警告
    if (duration > 1000) {
      console.warn(`Slow search detected: ${query} took ${duration}ms`);
    }
    
    return results;
  } catch (error) {
    console.error('Search error:', error);
    throw error;
  }
}
```

## 7. 环境变量配置

```env
# Pinecone
PINECONE_API_KEY=your-pinecone-api-key
PINECONE_ENVIRONMENT=us-east-1-aws
PINECONE_INDEX_NAME=blog-posts

# Supabase
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# Qdrant
QDRANT_URL=https://your-cluster.qdrant.io
QDRANT_API_KEY=your-qdrant-api-key

# OpenAI (用于生成嵌入向量)
OPENAI_API_KEY=sk-...

# Firecrawl (用于网页爬取)
FIRECRAWL_API_KEY=fc-...
```

## 8. 最佳实践

### 1. 选择合适的搜索方案

- **纯关键词搜索**: 使用 Orama
- **语义搜索**: 使用向量数据库
- **混合搜索**: 结合两者

### 2. 优化索引策略

- 定期更新索引
- 使用增量索引
- 删除过期文档

### 3. 提升搜索体验

- 实时搜索建议
- 搜索历史
- 热门搜索
- 相关搜索

### 4. 性能优化

- 缓存搜索结果
- 使用 CDN
- 异步索引更新
- 分页加载

### 5. 监控和分析

- 记录搜索查询
- 分析搜索模式
- 优化搜索算法
- A/B 测试

## 总结

MkSaaS 提供了完整的搜索解决方案：

1. **Orama 全文搜索**: 快速、轻量、实时
2. **向量搜索**: 支持 Pinecone、Supabase、Qdrant
3. **混合搜索**: 结合关键词和语义搜索
4. **实时建议**: 自动完成和搜索建议
5. **搜索分析**: 记录和分析搜索行为
6. **性能优化**: 缓存、索引优化、监控

通过这些工具和技术，可以构建强大的搜索功能，提供优秀的用户体验。
