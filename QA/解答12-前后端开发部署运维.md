# 问题12：关于开发的部署的服务器端的运维的，如果是有前端以及后端的操作过程如何处理？批量的脚本以及监控的策略

## 概述

MkSaaS 采用现代化的全栈开发模式，使用 Next.js 统一前后端开发，通过 Server Actions 和 API Routes 实现后端逻辑，配合完善的脚本工具和监控策略，实现高效的开发部署运维流程。

## 一、前后端架构

### 1. 技术栈

```
前端层:
├── React 19 (Server Components + Client Components)
├── Next.js 15 (App Router)
├── TypeScript
├── Tailwind CSS
└── shadcn/ui 组件库

后端层:
├── Next.js API Routes
├── Server Actions
├── Drizzle ORM
├── PostgreSQL
└── Better Auth

运行时:
├── Node.js 20
├── Edge Runtime (部分 API)
└── Serverless Functions
```

### 2. 前后端分离策略

虽然使用 Next.js 统一开发，但逻辑上仍然分离：

```
src/
├── app/                    # 前端路由和页面
│   ├── [locale]/          # 页面组件
│   └── api/               # 后端 API 路由
├── actions/               # Server Actions (后端逻辑)
├── components/            # 前端组件
├── lib/                   # 共享工具库
├── db/                    # 数据库层
├── payment/               # 支付模块
├── mail/                  # 邮件模块
└── storage/               # 存储模块
```

## 二、开发流程

### 1. 本地开发环境搭建

#### 安装依赖

```bash
# 克隆项目
git clone https://github.com/MkSaaSHQ/mksaas-blog
cd mksaas-blog

# 安装依赖
pnpm install

# 配置环境变量
cp env.example .env.local

# 编辑 .env.local 填入必要的配置
```

#### 环境变量配置

```env
# .env.local

# 数据库
DATABASE_URL=postgresql://user:password@localhost:5432/mksaas

# Better Auth
BETTER_AUTH_SECRET=your-secret-key-min-32-chars
BETTER_AUTH_URL=http://localhost:3000

# OAuth
GITHUB_CLIENT_ID=your-github-client-id
GITHUB_CLIENT_SECRET=your-github-client-secret
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret

# Stripe
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...

# 邮件
RESEND_API_KEY=re_...

# 存储
STORAGE_REGION=auto
STORAGE_ACCESS_KEY_ID=your-key
STORAGE_SECRET_ACCESS_KEY=your-secret
STORAGE_BUCKET_NAME=your-bucket
STORAGE_ENDPOINT=https://your-endpoint.com
STORAGE_PUBLIC_URL=https://cdn.yourdomain.com
```

#### 初始化数据库

```bash
# 推送 schema 到数据库
pnpm db:push

# 或运行迁移
pnpm db:generate
pnpm db:migrate

# 打开数据库管理界面
pnpm db:studio
```

#### 启动开发服务器

```bash
# 启动 Next.js 开发服务器
pnpm dev

# 访问 http://localhost:3005
```

### 2. 前端开发流程

#### 创建新页面

```typescript
// src/app/[locale]/(marketing)/my-page/page.tsx
import { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'My Page',
  description: 'Page description',
};

export default function MyPage() {
  return (
    <div className="container py-8">
      <h1>My Page</h1>
      {/* 页面内容 */}
    </div>
  );
}
```

#### 创建组件

```typescript
// src/components/my-feature/my-component.tsx
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';

export function MyComponent() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <Button onClick={() => setCount(count + 1)}>
        Increment
      </Button>
    </div>
  );
}
```

#### 使用 Server Components

```typescript
// src/app/[locale]/(marketing)/posts/page.tsx
import { db } from '@/db';
import { blog } from '@/db/schema';

// 这是一个 Server Component，可以直接访问数据库
export default async function PostsPage() {
  const posts = await db.select().from(blog);
  
  return (
    <div>
      {posts.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.description}</p>
        </article>
      ))}
    </div>
  );
}
```

### 3. 后端开发流程

#### 创建 Server Action

```typescript
// src/actions/my-action.ts
'use server';

import { userActionClient } from '@/lib/safe-action';
import { z } from 'zod';
import { db } from '@/db';
import { myTable } from '@/db/schema';
import { nanoid } from 'nanoid';

const schema = z.object({
  name: z.string().min(1).max(100),
  description: z.string().optional(),
});

export const createItemAction = userActionClient
  .schema(schema)
  .action(async ({ parsedInput, ctx }) => {
    // ctx.user 包含当前登录用户信息
    const userId = ctx.user.id;
    
    try {
      // 数据库操作
      const newItem = await db.insert(myTable).values({
        id: nanoid(),
        userId,
        name: parsedInput.name,
        description: parsedInput.description,
        createdAt: new Date(),
        updatedAt: new Date(),
      }).returning();
      
      return {
        success: true,
        data: newItem[0],
      };
    } catch (error) {
      console.error('Create item error:', error);
      return {
        success: false,
        error: 'Failed to create item',
      };
    }
  });
```

#### 创建 API 路由

```typescript
// src/app/api/my-endpoint/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import { db } from '@/db';

// GET 请求
export async function GET(req: NextRequest) {
  try {
    // 获取当前用户
    const session = await getSession();
    
    if (!session) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }
    
    // 业务逻辑
    const data = await db.select().from(myTable);
    
    return NextResponse.json({
      success: true,
      data,
    });
  } catch (error) {
    console.error('API error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// POST 请求
export async function POST(req: NextRequest) {
  try {
    const session = await getSession();
    
    if (!session) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }
    
    const body = await req.json();
    
    // 验证输入
    const validated = schema.parse(body);
    
    // 业务逻辑
    const result = await createItem(validated);
    
    return NextResponse.json({
      success: true,
      data: result,
    });
  } catch (error) {
    console.error('API error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// 配置运行时（可选）
export const runtime = 'edge'; // 或 'nodejs'
export const dynamic = 'force-dynamic'; // 禁用缓存
```

### 4. 数据库操作

#### 使用 Drizzle ORM

```typescript
// src/lib/data/my-data.ts
import { db } from '@/db';
import { myTable } from '@/db/schema';
import { eq, and, desc, gte } from 'drizzle-orm';

// 查询
export async function getItems(userId: string) {
  return await db
    .select()
    .from(myTable)
    .where(eq(myTable.userId, userId))
    .orderBy(desc(myTable.createdAt));
}

// 插入
export async function createItem(data: InsertItem) {
  return await db
    .insert(myTable)
    .values(data)
    .returning();
}

// 更新
export async function updateItem(id: string, data: Partial<InsertItem>) {
  return await db
    .update(myTable)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(eq(myTable.id, id))
    .returning();
}

// 删除
export async function deleteItem(id: string) {
  return await db
    .delete(myTable)
    .where(eq(myTable.id, id));
}

// 事务
export async function transferCredits(fromUserId: string, toUserId: string, amount: number) {
  await db.transaction(async (tx) => {
    // 扣除发送方积分
    await tx
      .update(userCredit)
      .set({
        currentCredits: sql`${userCredit.currentCredits} - ${amount}`,
      })
      .where(eq(userCredit.userId, fromUserId));
    
    // 增加接收方积分
    await tx
      .update(userCredit)
      .set({
        currentCredits: sql`${userCredit.currentCredits} + ${amount}`,
      })
      .where(eq(userCredit.userId, toUserId));
    
    // 记录交易
    await tx.insert(creditTransaction).values([
      {
        id: nanoid(),
        userId: fromUserId,
        type: 'transfer_out',
        amount: -amount,
        createdAt: new Date(),
      },
      {
        id: nanoid(),
        userId: toUserId,
        type: 'transfer_in',
        amount: amount,
        createdAt: new Date(),
      },
    ]);
  });
}
```

## 三、批量脚本工具

### 1. 现有脚本

MkSaaS 提供了多个实用脚本：

```
scripts/
├── list-users.ts              # 列出所有用户
├── list-contacts.ts           # 列出 Newsletter 订阅者
├── fix-payments.ts            # 修复支付数据
└── fix-payments-scene.ts      # 修复支付场景
```

#### 列出用户脚本

```typescript
// scripts/list-users.ts
import dotenv from 'dotenv';
import { getDb } from '../src/db/index.js';
import { user } from '../src/db/schema.js';
dotenv.config();

export default async function listUsers() {
  const db = await getDb();

  try {
    const users = await db.select({ 
      email: user.email,
      name: user.name,
      createdAt: user.createdAt,
    }).from(user);

    console.log(`Total users: ${users.length}`);
    
    // 输出所有邮箱
    const emails = users.map(u => u.email);
    console.log(emails.join(', '));
    
    console.log('List users completed');
  } catch (error) {
    console.error('Error fetching users:', error);
  }
}

listUsers();
```

运行脚本：

```bash
pnpm list-users
```

#### 修复支付数据脚本

```typescript
// scripts/fix-payments.ts
import dotenv from 'dotenv';
import { eq } from 'drizzle-orm';
import { getDb } from '../src/db/index.js';
import { payment } from '../src/db/schema.js';
dotenv.config();

export default async function fixPayments() {
  const db = await getDb();

  try {
    const payments = await db.select().from(payment);

    for (const record of payments) {
      if (record.paid) {
        continue;
      }
      
      const isOneTimePayment =
        record.type === 'one_time' && record.status === 'completed';
      const isSubscriptionPayment =
        record.type === 'subscription' &&
        (record.status === 'active' || record.status === 'trialing');
        
      if (isOneTimePayment || isSubscriptionPayment) {
        console.log('Updating payment, id:', record.id);
        
        await db
          .update(payment)
          .set({ paid: true })
          .where(eq(payment.id, record.id));
      }
    }

    console.log('Fix payments completed');
  } catch (error) {
    console.error('Fix payments error:', error);
  }
}

fixPayments();
```

### 2. 创建自定义脚本

#### 批量导入用户脚本

```typescript
// scripts/import-users.ts
import dotenv from 'dotenv';
import { getDb } from '../src/db/index.js';
import { user, account } from '../src/db/schema.js';
import { nanoid } from 'nanoid';
import fs from 'fs';
import csv from 'csv-parser';
dotenv.config();

interface UserData {
  email: string;
  name: string;
}

async function importUsers(csvFilePath: string) {
  const db = await getDb();
  const users: UserData[] = [];
  
  // 读取 CSV 文件
  await new Promise((resolve, reject) => {
    fs.createReadStream(csvFilePath)
      .pipe(csv())
      .on('data', (row) => {
        users.push({
          email: row.email,
          name: row.name,
        });
      })
      .on('end', resolve)
      .on('error', reject);
  });
  
  console.log(`Found ${users.length} users to import`);
  
  // 批量导入
  for (const userData of users) {
    try {
      // 检查用户是否已存在
      const existing = await db
        .select()
        .from(user)
        .where(eq(user.email, userData.email))
        .limit(1);
      
      if (existing.length > 0) {
        console.log(`User ${userData.email} already exists, skipping`);
        continue;
      }
      
      // 创建用户
      const userId = nanoid();
      await db.insert(user).values({
        id: userId,
        name: userData.name,
        email: userData.email,
        emailVerified: false,
        createdAt: new Date(),
        updatedAt: new Date(),
      });
      
      console.log(`Imported user: ${userData.email}`);
    } catch (error) {
      console.error(`Error importing user ${userData.email}:`, error);
    }
  }
  
  console.log('Import completed');
}

// 运行脚本
const csvFile = process.argv[2];
if (!csvFile) {
  console.error('Usage: tsx scripts/import-users.ts <csv-file>');
  process.exit(1);
}

importUsers(csvFile);
```

运行：

```bash
tsx scripts/import-users.ts users.csv
```

#### 批量发送邮件脚本

```typescript
// scripts/send-bulk-email.ts
import dotenv from 'dotenv';
import { getDb } from '../src/db/index.js';
import { user } from '../src/db/schema.js';
import { sendEmail } from '../src/mail/index.js';
dotenv.config();

async function sendBulkEmail(subject: string, template: string) {
  const db = await getDb();
  
  // 获取所有用户
  const users = await db
    .select({
      email: user.email,
      name: user.name,
    })
    .from(user)
    .where(eq(user.emailVerified, true));
  
  console.log(`Sending email to ${users.length} users`);
  
  let successCount = 0;
  let failCount = 0;
  
  for (const u of users) {
    try {
      await sendEmail({
        to: u.email,
        template: template as any,
        context: {
          name: u.name,
          // 其他上下文数据
        },
      });
      
      successCount++;
      console.log(`✓ Sent to ${u.email}`);
      
      // 避免速率限制，延迟 1 秒
      await new Promise(resolve => setTimeout(resolve, 1000));
    } catch (error) {
      failCount++;
      console.error(`✗ Failed to send to ${u.email}:`, error);
    }
  }
  
  console.log(`\nCompleted: ${successCount} success, ${failCount} failed`);
}

// 运行脚本
const template = process.argv[2];
if (!template) {
  console.error('Usage: tsx scripts/send-bulk-email.ts <template-name>');
  process.exit(1);
}

sendBulkEmail('Important Update', template);
```

#### 数据清理脚本

```typescript
// scripts/cleanup-expired-data.ts
import dotenv from 'dotenv';
import { getDb } from '../src/db/index.js';
import { creditTransaction, session } from '../src/db/schema.js';
import { lt, and, isNull } from 'drizzle-orm';
dotenv.config();

async function cleanupExpiredData() {
  const db = await getDb();
  const now = new Date();
  
  try {
    // 清理过期的会话
    const deletedSessions = await db
      .delete(session)
      .where(lt(session.expiresAt, now))
      .returning();
    
    console.log(`Deleted ${deletedSessions.length} expired sessions`);
    
    // 处理过期的积分
    const expiredCredits = await db
      .select()
      .from(creditTransaction)
      .where(
        and(
          lt(creditTransaction.expirationDate, now),
          isNull(creditTransaction.expirationDateProcessedAt)
        )
      );
    
    console.log(`Found ${expiredCredits.length} expired credit transactions`);
    
    for (const credit of expiredCredits) {
      // 扣除过期积分
      // ... 实现逻辑
      
      // 标记为已处理
      await db
        .update(creditTransaction)
        .set({
          expirationDateProcessedAt: now,
        })
        .where(eq(creditTransaction.id, credit.id));
    }
    
    console.log('Cleanup completed');
  } catch (error) {
    console.error('Cleanup error:', error);
  }
}

cleanupExpiredData();
```

### 3. 定时任务

#### 使用 Cron Jobs

```typescript
// scripts/cron/daily-cleanup.ts
import { cleanupExpiredData } from '../cleanup-expired-data.js';
import { sendDailyReport } from '../send-daily-report.js';

async function dailyTasks() {
  console.log('Starting daily tasks...');
  
  try {
    // 清理过期数据
    await cleanupExpiredData();
    
    // 发送日报
    await sendDailyReport();
    
    console.log('Daily tasks completed');
  } catch (error) {
    console.error('Daily tasks error:', error);
    // 发送错误通知
  }
}

dailyTasks();
```

#### 配置 Cron（Linux/Mac）

```bash
# 编辑 crontab
crontab -e

# 添加定时任务（每天凌晨 2 点执行）
0 2 * * * cd /path/to/project && tsx scripts/cron/daily-cleanup.ts >> /var/log/mksaas-cron.log 2>&1
```

#### 使用 GitHub Actions

```yaml
# .github/workflows/daily-tasks.yml
name: Daily Tasks

on:
  schedule:
    # 每天 UTC 时间 02:00 执行
    - cron: '0 2 * * *'
  workflow_dispatch: # 允许手动触发

jobs:
  daily-tasks:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
      
      - name: Install pnpm
        run: npm install -g pnpm
      
      - name: Install dependencies
        run: pnpm install
      
      - name: Run daily tasks
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
        run: tsx scripts/cron/daily-cleanup.ts
```

## 四、监控策略

### 1. 应用监控

#### Vercel Analytics

```typescript
// src/app/layout.tsx
import { Analytics } from '@vercel/analytics/react';
import { SpeedInsights } from '@vercel/speed-insights/next';

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        {children}
        <Analytics />
        <SpeedInsights />
      </body>
    </html>
  );
}
```

配置：

```typescript
// src/config/website.tsx
export const websiteConfig = {
  analytics: {
    enableVercelAnalytics: true,
    enableSpeedInsights: true,
  },
};
```

#### Sentry 错误追踪

安装：

```bash
pnpm add @sentry/nextjs
```

配置：

```typescript
// sentry.client.config.ts
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,
  replaysSessionSampleRate: 0.1,
  replaysOnErrorSampleRate: 1.0,
});
```

```typescript
// sentry.server.config.ts
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,
});
```

使用：

```typescript
// 捕获错误
try {
  await riskyOperation();
} catch (error) {
  Sentry.captureException(error, {
    tags: {
      section: 'payment',
    },
    extra: {
      userId: user.id,
    },
  });
  throw error;
}
```

#### PostHog 产品分析

```typescript
// src/analytics/posthog-analytics.tsx
'use client';

import posthog from 'posthog-js';
import { PostHogProvider } from 'posthog-js/react';
import { useEffect } from 'react';

export function PostHogAnalytics({ children }) {
  useEffect(() => {
    posthog.init(process.env.NEXT_PUBLIC_POSTHOG_KEY!, {
      api_host: process.env.NEXT_PUBLIC_POSTHOG_HOST,
      capture_pageview: false,
    });
  }, []);
  
  return <PostHogProvider client={posthog}>{children}</PostHogProvider>;
}
```

追踪事件：

```typescript
import { usePostHog } from 'posthog-js/react';

function MyComponent() {
  const posthog = usePostHog();
  
  const handleClick = () => {
    posthog.capture('button_clicked', {
      button_name: 'subscribe',
      plan: 'pro',
    });
  };
  
  return <button onClick={handleClick}>Subscribe</button>;
}
```

### 2. 性能监控

#### 自定义性能监控

```typescript
// src/lib/monitoring/performance.ts
export class PerformanceMonitor {
  private static instance: PerformanceMonitor;
  
  private constructor() {}
  
  static getInstance() {
    if (!this.instance) {
      this.instance = new PerformanceMonitor();
    }
    return this.instance;
  }
  
  // 监控函数执行时间
  async measureAsync<T>(
    name: string,
    fn: () => Promise<T>
  ): Promise<T> {
    const start = Date.now();
    
    try {
      const result = await fn();
      const duration = Date.now() - start;
      
      this.logMetric(name, duration, 'success');
      
      return result;
    } catch (error) {
      const duration = Date.now() - start;
      this.logMetric(name, duration, 'error');
      throw error;
    }
  }
  
  private logMetric(name: string, duration: number, status: string) {
    console.log(`[Performance] ${name}: ${duration}ms (${status})`);
    
    // 发送到监控服务
    if (duration > 1000) {
      console.warn(`[Performance] Slow operation detected: ${name}`);
    }
  }
}

// 使用
const monitor = PerformanceMonitor.getInstance();

export async function mySlowFunction() {
  return await monitor.measureAsync('mySlowFunction', async () => {
    // 执行耗时操作
    await heavyComputation();
    return result;
  });
}
```

#### API 响应时间监控

```typescript
// src/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const start = Date.now();
  
  const response = NextResponse.next();
  
  // 添加响应时间头
  response.headers.set('X-Response-Time', `${Date.now() - start}ms`);
  
  // 记录慢请求
  const duration = Date.now() - start;
  if (duration > 1000) {
    console.warn(`Slow request: ${request.url} took ${duration}ms`);
  }
  
  return response;
}
```

### 3. 数据库监控

#### 查询性能监控

```typescript
// src/db/index.ts
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

const client = postgres(process.env.DATABASE_URL!, {
  max: 10,
  onnotice: (notice) => {
    console.log('PostgreSQL notice:', notice);
  },
});

export const db = drizzle(client, {
  schema,
  logger: {
    logQuery(query, params) {
      const start = Date.now();
      
      // 记录查询
      console.log('Query:', query);
      console.log('Params:', params);
      
      // 监控慢查询
      const duration = Date.now() - start;
      if (duration > 100) {
        console.warn(`Slow query detected: ${duration}ms`);
      }
    },
  },
});
```

#### 连接池监控

```typescript
// 监控数据库连接
setInterval(() => {
  const stats = client.options;
  console.log('Database connections:', {
    max: stats.max,
    idle: stats.idle_timeout,
  });
}, 60000); // 每分钟检查一次
```

### 4. 日志管理

#### 结构化日志

```typescript
// src/lib/logger.ts
export enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  WARN = 'warn',
  ERROR = 'error',
}

interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: string;
  context?: Record<string, any>;
  error?: Error;
}

export class Logger {
  private static instance: Logger;
  
  private constructor() {}
  
  static getInstance() {
    if (!this.instance) {
      this.instance = new Logger();
    }
    return this.instance;
  }
  
  private log(entry: LogEntry) {
    const logData = {
      ...entry,
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV,
    };
    
    // 输出到控制台
    console.log(JSON.stringify(logData));
    
    // 发送到日志服务（如 Datadog, LogRocket）
    if (process.env.NODE_ENV === 'production') {
      this.sendToLogService(logData);
    }
  }
  
  debug(message: string, context?: Record<string, any>) {
    this.log({ level: LogLevel.DEBUG, message, context });
  }
  
  info(message: string, context?: Record<string, any>) {
    this.log({ level: LogLevel.INFO, message, context });
  }
  
  warn(message: string, context?: Record<string, any>) {
    this.log({ level: LogLevel.WARN, message, context });
  }
  
  error(message: string, error?: Error, context?: Record<string, any>) {
    this.log({ level: LogLevel.ERROR, message, error, context });
  }
  
  private sendToLogService(logData: LogEntry) {
    // 实现发送到日志服务的逻辑
  }
}

// 使用
const logger = Logger.getInstance();

logger.info('User logged in', { userId: user.id });
logger.error('Payment failed', error, { userId: user.id, amount: 100 });
```

#### 请求日志中间件

```typescript
// src/middleware.ts
import { Logger } from '@/lib/logger';

const logger = Logger.getInstance();

export function middleware(request: NextRequest) {
  const start = Date.now();
  
  logger.info('Request started', {
    method: request.method,
    url: request.url,
    userAgent: request.headers.get('user-agent'),
  });
  
  const response = NextResponse.next();
  
  const duration = Date.now() - start;
  
  logger.info('Request completed', {
    method: request.method,
    url: request.url,
    status: response.status,
    duration,
  });
  
  return response;
}
```

### 5. 健康检查

#### 健康检查端点

```typescript
// src/app/api/health/route.ts
import { NextResponse } from 'next/server';
import { db } from '@/db';
import { user } from '@/db/schema';

export async function GET() {
  const checks = {
    database: false,
    timestamp: new Date().toISOString(),
  };
  
  try {
    // 检查数据库连接
    await db.select().from(user).limit(1);
    checks.database = true;
  } catch (error) {
    console.error('Database health check failed:', error);
  }
  
  const isHealthy = checks.database;
  
  return NextResponse.json(
    {
      status: isHealthy ? 'healthy' : 'unhealthy',
      checks,
    },
    { status: isHealthy ? 200 : 503 }
  );
}
```

#### 详细健康检查

```typescript
// src/app/api/health/detailed/route.ts
import { NextResponse } from 'next/server';
import { db } from '@/db';
import { Redis } from '@upstash/redis';

export async function GET() {
  const checks = {
    database: { status: 'unknown', latency: 0 },
    redis: { status: 'unknown', latency: 0 },
    storage: { status: 'unknown', latency: 0 },
  };
  
  // 数据库检查
  try {
    const start = Date.now();
    await db.select().from(user).limit(1);
    checks.database = {
      status: 'healthy',
      latency: Date.now() - start,
    };
  } catch (error) {
    checks.database.status = 'unhealthy';
  }
  
  // Redis 检查
  if (process.env.REDIS_URL) {
    try {
      const redis = Redis.fromEnv();
      const start = Date.now();
      await redis.ping();
      checks.redis = {
        status: 'healthy',
        latency: Date.now() - start,
      };
    } catch (error) {
      checks.redis.status = 'unhealthy';
    }
  }
  
  // 存储检查
  try {
    const start = Date.now();
    // 测试存储连接
    checks.storage = {
      status: 'healthy',
      latency: Date.now() - start,
    };
  } catch (error) {
    checks.storage.status = 'unhealthy';
  }
  
  const isHealthy = Object.values(checks).every(
    check => check.status === 'healthy'
  );
  
  return NextResponse.json(
    {
      status: isHealthy ? 'healthy' : 'degraded',
      checks,
      timestamp: new Date().toISOString(),
    },
    { status: isHealthy ? 200 : 503 }
  );
}
```

### 6. 告警系统

#### Discord 通知

```typescript
// src/notification/discord.ts
export async function sendDiscordNotification(message: string, severity: 'info' | 'warning' | 'error') {
  const webhookUrl = process.env.DISCORD_WEBHOOK_URL;
  
  if (!webhookUrl) return;
  
  const colors = {
    info: 0x3498db,
    warning: 0xf39c12,
    error: 0xe74c3c,
  };
  
  await fetch(webhookUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      embeds: [{
        title: `[${severity.toUpperCase()}] MkSaaS Alert`,
        description: message,
        color: colors[severity],
        timestamp: new Date().toISOString(),
      }],
    }),
  });
}

// 使用
await sendDiscordNotification(
  'Database connection failed',
  'error'
);
```

#### 邮件告警

```typescript
// src/notification/email-alert.ts
import { sendEmail } from '@/mail';

export async function sendEmailAlert(
  subject: string,
  message: string,
  severity: 'info' | 'warning' | 'error'
) {
  const adminEmail = process.env.ADMIN_EMAIL;
  
  if (!adminEmail) return;
  
  await sendEmail({
    to: adminEmail,
    subject: `[${severity.toUpperCase()}] ${subject}`,
    html: `
      <h2>${subject}</h2>
      <p>${message}</p>
      <p>Time: ${new Date().toISOString()}</p>
    `,
  });
}
```

## 五、CI/CD 流程

### 1. GitHub Actions 工作流

#### 测试和构建

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
      
      - name: Install pnpm
        run: npm install -g pnpm
      
      - name: Install dependencies
        run: pnpm install
      
      - name: Lint
        run: pnpm lint
      
      - name: Type check
        run: pnpm tsc --noEmit
      
      - name: Build
        run: pnpm build
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
```

#### 自动部署

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
```

### 2. 部署前检查

```bash
# scripts/pre-deploy.sh
#!/bin/bash

echo "Running pre-deployment checks..."

# 检查环境变量
if [ -z "$DATABASE_URL" ]; then
  echo "Error: DATABASE_URL is not set"
  exit 1
fi

# 运行测试
pnpm test

# 运行类型检查
pnpm tsc --noEmit

# 运行 lint
pnpm lint

# 构建项目
pnpm build

echo "Pre-deployment checks passed!"
```

### 3. 部署后验证

```bash
# scripts/post-deploy.sh
#!/bin/bash

echo "Running post-deployment validation..."

# 检查健康端点
HEALTH_URL="https://yourdomain.com/api/health"
RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_URL)

if [ $RESPONSE -eq 200 ]; then
  echo "Health check passed"
else
  echo "Health check failed with status $RESPONSE"
  exit 1
fi

# 运行冒烟测试
# ...

echo "Post-deployment validation passed!"
```

## 六、最佳实践

### 1. 开发规范

- 使用 TypeScript 严格模式
- 遵循 ESLint 规则
- 编写有意义的提交信息
- 代码审查（Pull Request）
- 单元测试覆盖关键逻辑

### 2. 安全实践

- 永远不要提交敏感信息到代码库
- 使用环境变量管理配置
- 定期更新依赖
- 实施速率限制
- 验证所有用户输入

### 3. 性能优化

- 使用 React Server Components
- 实施适当的缓存策略
- 优化数据库查询
- 使用 CDN 分发静态资源
- 监控和优化慢查询

### 4. 运维规范

- 定期备份数据库
- 监控系统健康状态
- 设置告警机制
- 保持文档更新
- 制定灾难恢复计划

## 总结

MkSaaS 提供了完整的开发部署运维解决方案：

1. **前后端统一**: Next.js 全栈开发
2. **批量脚本**: 丰富的管理脚本工具
3. **监控体系**: 多维度监控和日志
4. **CI/CD**: 自动化部署流程
5. **健康检查**: 完善的健康监控
6. **告警系统**: 及时的问题通知

通过这些工具和流程，可以高效地开发、部署和运维 SaaS 应用。
