# é—®é¢˜26ï¼šé¡¹ç›®æ¶æ„å®‰å…¨é£é™©è¯„ä¼°ä¸é˜²æŠ¤æªæ–½

## æ¦‚è¿°

æœ¬æ–‡å¯¹ MkSaaS é¡¹ç›®è¿›è¡Œå…¨é¢çš„å®‰å…¨é£é™©è¯„ä¼°ï¼Œè¯†åˆ«æ½œåœ¨çš„å®‰å…¨å¨èƒï¼Œå¹¶æä¾›è¯¦ç»†çš„é˜²æŠ¤æªæ–½å’Œæœ€ä½³å®è·µã€‚é‡ç‚¹å…³æ³¨ API æ»¥ç”¨ã€å¯†é’¥æ³„éœ²ã€ç›—åˆ·ã€æ”¯ä»˜å®‰å…¨ç­‰å…³é”®é—®é¢˜ã€‚

## ä¸€ã€å®‰å…¨é£é™©è¯„ä¼°çŸ©é˜µ

### 1. é£é™©ç­‰çº§åˆ†ç±»

| é£é™©ç±»åˆ« | é£é™©ç­‰çº§ | å½±å“èŒƒå›´ | å‘ç”Ÿæ¦‚ç‡ | ä¼˜å…ˆçº§ |
|---------|---------|---------|---------|--------|
| API å¯†é’¥æ³„éœ² | ğŸ”´ ä¸¥é‡ | å…¨å±€ | ä¸­ | P0 |
| æ¨¡å‹ API æ»¥ç”¨ | ğŸ”´ ä¸¥é‡ | æˆæœ¬ | é«˜ | P0 |
| æ”¯ä»˜ç³»ç»Ÿæ¼æ´ | ğŸ”´ ä¸¥é‡ | è´¢åŠ¡ | ä½ | P0 |
| ç”¨æˆ·æ•°æ®æ³„éœ² | ğŸ”´ ä¸¥é‡ | éšç§ | ä¸­ | P0 |
| DDoS æ”»å‡» | ğŸŸ¡ é«˜ | å¯ç”¨æ€§ | ä¸­ | P1 |
| SQL æ³¨å…¥ | ğŸŸ¡ é«˜ | æ•°æ® | ä½ | P1 |
| XSS æ”»å‡» | ğŸŸ¡ é«˜ | ç”¨æˆ· | ä¸­ | P1 |
| CSRF æ”»å‡» | ğŸŸ¢ ä¸­ | æ“ä½œ | ä½ | P2 |

## äºŒã€API å¯†é’¥å®‰å…¨

### 1. å‰ç«¯å¯†é’¥æ³„éœ²é£é™©

**é£é™©æè¿°**:
- å‰ç«¯ä»£ç ä¸­ç¡¬ç¼–ç  API å¯†é’¥
- ç¯å¢ƒå˜é‡æš´éœ²åœ¨å®¢æˆ·ç«¯
- æµè§ˆå™¨å¼€å‘å·¥å…·å¯è§

**é˜²æŠ¤æªæ–½**:

```typescript
// âŒ é”™è¯¯åšæ³•ï¼šå‰ç«¯ç›´æ¥ä½¿ç”¨å¯†é’¥
const openai = new OpenAI({
  apiKey: 'sk-xxxxx', // æ°¸è¿œä¸è¦è¿™æ ·åšï¼
});

// âœ… æ­£ç¡®åšæ³•ï¼šé€šè¿‡åç«¯ä»£ç†
// src/app/api/ai/generate/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { OpenAI } from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY, // ä»…åœ¨æœåŠ¡ç«¯
});

export async function POST(req: NextRequest) {
  // 1. éªŒè¯ç”¨æˆ·èº«ä»½
  const session = await auth();
  if (!session?.user) {
    return new NextResponse('Unauthorized', { status: 401 });
  }
  
  // 2. æ£€æŸ¥ç”¨æˆ·æƒé™
  const hasPermission = await checkUserPermission(session.user.id, 'ai:generate');
  if (!hasPermission) {
    return new NextResponse('Forbidden', { status: 403 });
  }
  
  // 3. é€Ÿç‡é™åˆ¶
  const rateLimit = await checkRateLimit(session.user.id, 'ai-generation');
  if (!rateLimit.success) {
    return NextResponse.json(
      { error: 'è¯·æ±‚è¿‡äºé¢‘ç¹' },
      { status: 429 }
    );
  }
  
  // 4. éªŒè¯è¯·æ±‚å‚æ•°
  const { prompt } = await req.json();
  if (!prompt || prompt.length > 4000) {
    return NextResponse.json(
      { error: 'æ— æ•ˆçš„è¯·æ±‚å‚æ•°' },
      { status: 400 }
    );
  }
  
  // 5. è°ƒç”¨ API
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 1000, // é™åˆ¶ token æ•°é‡
    });
    
    // 6. è®°å½•ä½¿ç”¨æƒ…å†µ
    await logAPIUsage({
      userId: session.user.id,
      model: 'gpt-3.5-turbo',
      tokens: response.usage?.total_tokens || 0,
      cost: calculateCost(response.usage?.total_tokens || 0),
    });
    
    return NextResponse.json({
      text: response.choices[0].message.content,
    });
  } catch (error) {
    console.error('AI generation error:', error);
    return NextResponse.json(
      { error: 'ç”Ÿæˆå¤±è´¥' },
      { status: 500 }
    );
  }
}
```

### 2. ç¯å¢ƒå˜é‡å®‰å…¨ç®¡ç†

```typescript
// src/lib/env.ts
import { z } from 'zod';

// å®šä¹‰ç¯å¢ƒå˜é‡ schema
const envSchema = z.object({
  // æ•°æ®åº“
  DATABASE_URL: z.string().url(),
  
  // API å¯†é’¥ï¼ˆä»…æœåŠ¡ç«¯ï¼‰
  OPENAI_API_KEY: z.string().startsWith('sk-'),
  STRIPE_SECRET_KEY: z.string().startsWith('sk_'),
  
  // å…¬å¼€å¯†é’¥ï¼ˆå¯åœ¨å®¢æˆ·ç«¯ä½¿ç”¨ï¼‰
  NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: z.string().startsWith('pk_'),
  NEXT_PUBLIC_APP_URL: z.string().url(),
});

// éªŒè¯ç¯å¢ƒå˜é‡
export const env = envSchema.parse(process.env);

// ä½¿ç”¨ç¤ºä¾‹
import { env } from '@/lib/env';

const openai = new OpenAI({
  apiKey: env.OPENAI_API_KEY, // ç±»å‹å®‰å…¨
});
```

### 3. å¯†é’¥è½®æ¢ç­–ç•¥

```typescript
// src/lib/security/key-rotation.ts
export class KeyRotationService {
  // æ£€æŸ¥å¯†é’¥æ˜¯å¦éœ€è¦è½®æ¢
  async checkKeyRotation(keyName: string): Promise<boolean> {
    const lastRotation = await db.query.keyRotations.findFirst({
      where: eq(keyRotations.keyName, keyName),
      orderBy: desc(keyRotations.rotatedAt),
    });
    
    if (!lastRotation) {
      return true; // ä»æœªè½®æ¢è¿‡
    }
    
    const daysSinceRotation = 
      (Date.now() - lastRotation.rotatedAt.getTime()) / (1000 * 60 * 60 * 24);
    
    return daysSinceRotation > 90; // 90å¤©è½®æ¢ä¸€æ¬¡
  }
  
  // è½®æ¢å¯†é’¥
  async rotateKey(keyName: string, newKey: string): Promise<void> {
    // 1. éªŒè¯æ–°å¯†é’¥
    if (!this.validateKey(keyName, newKey)) {
      throw new Error('Invalid key format');
    }
    
    // 2. æ›´æ–°ç¯å¢ƒå˜é‡ï¼ˆéœ€è¦é‡å¯æœåŠ¡ï¼‰
    // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œè¿™é€šå¸¸é€šè¿‡ CI/CD æˆ–å¯†é’¥ç®¡ç†æœåŠ¡å®Œæˆ
    
    // 3. è®°å½•è½®æ¢
    await db.insert(keyRotations).values({
      keyName,
      rotatedAt: new Date(),
      rotatedBy: 'system',
    });
    
    // 4. å‘é€é€šçŸ¥
    await this.notifyKeyRotation(keyName);
  }
  
  private validateKey(keyName: string, key: string): boolean {
    const patterns: Record<string, RegExp> = {
      OPENAI_API_KEY: /^sk-[A-Za-z0-9]{48}$/,
      STRIPE_SECRET_KEY: /^sk_(test|live)_[A-Za-z0-9]{24,}$/,
    };
    
    return patterns[keyName]?.test(key) ?? false;
  }
  
  private async notifyKeyRotation(keyName: string): Promise<void> {
    // å‘é€é€šçŸ¥ç»™ç®¡ç†å‘˜
    await mailService.send({
      to: process.env.ADMIN_EMAIL!,
      subject: `å¯†é’¥è½®æ¢é€šçŸ¥: ${keyName}`,
      template: 'key-rotation',
      data: { keyName, timestamp: new Date() },
    });
  }
}
```

## ä¸‰ã€æ¨¡å‹ API æ»¥ç”¨é˜²æŠ¤

### 1. å¤šå±‚é€Ÿç‡é™åˆ¶

```typescript
// src/lib/rate-limit/ai-rate-limit.ts
export class AIRateLimiter {
  // ç”¨æˆ·çº§é™åˆ¶
  async checkUserLimit(userId: string): Promise<RateLimitResult> {
    const key = `ai:user:${userId}`;
    
    // æ¯æ—¥é™åˆ¶
    const dailyLimit = await redis.get(`${key}:daily`);
    if (dailyLimit && parseInt(dailyLimit) >= 100) {
      return {
        allowed: false,
        reason: 'å·²è¾¾åˆ°æ¯æ—¥é™é¢ï¼ˆ100æ¬¡ï¼‰',
        resetAt: this.getNextDayTimestamp(),
      };
    }
    
    // æ¯å°æ—¶é™åˆ¶
    const hourlyLimit = await redis.get(`${key}:hourly`);
    if (hourlyLimit && parseInt(hourlyLimit) >= 20) {
      return {
        allowed: false,
        reason: 'å·²è¾¾åˆ°æ¯å°æ—¶é™é¢ï¼ˆ20æ¬¡ï¼‰',
        resetAt: this.getNextHourTimestamp(),
      };
    }
    
    // æ¯åˆ†é’Ÿé™åˆ¶
    const minuteLimit = await redis.get(`${key}:minute`);
    if (minuteLimit && parseInt(minuteLimit) >= 5) {
      return {
        allowed: false,
        reason: 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•',
        resetAt: this.getNextMinuteTimestamp(),
      };
    }
    
    return { allowed: true };
  }
  
  // å¢åŠ è®¡æ•°
  async incrementUsage(userId: string): Promise<void> {
    const key = `ai:user:${userId}`;
    
    await Promise.all([
      redis.incr(`${key}:daily`),
      redis.incr(`${key}:hourly`),
      redis.incr(`${key}:minute`),
    ]);
    
    // è®¾ç½®è¿‡æœŸæ—¶é—´
    await redis.expire(`${key}:daily`, 86400); // 24å°æ—¶
    await redis.expire(`${key}:hourly`, 3600); // 1å°æ—¶
    await redis.expire(`${key}:minute`, 60); // 1åˆ†é’Ÿ
  }
  
  // IP çº§é™åˆ¶
  async checkIPLimit(ip: string): Promise<RateLimitResult> {
    const key = `ai:ip:${ip}`;
    const count = await redis.incr(key);
    
    if (count === 1) {
      await redis.expire(key, 3600); // 1å°æ—¶
    }
    
    if (count > 50) {
      return {
        allowed: false,
        reason: 'IP è¯·æ±‚è¿‡å¤š',
        resetAt: Date.now() + 3600000,
      };
    }
    
    return { allowed: true };
  }
}

export const aiRateLimiter = new AIRateLimiter();
```

### 2. Token ä½¿ç”¨ç›‘æ§

```typescript
// src/lib/monitoring/token-monitor.ts
export class TokenMonitor {
  // è®°å½• token ä½¿ç”¨
  async recordUsage(data: {
    userId: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  }): Promise<void> {
    // 1. ä¿å­˜åˆ°æ•°æ®åº“
    await db.insert(tokenUsage).values({
      ...data,
      cost: this.calculateCost(data.model, data.totalTokens),
      timestamp: new Date(),
    });
    
    // 2. æ›´æ–°ç”¨æˆ·ç»Ÿè®¡
    await this.updateUserStats(data.userId, data.totalTokens);
    
    // 3. æ£€æŸ¥å¼‚å¸¸ä½¿ç”¨
    await this.checkAnomalousUsage(data.userId, data.totalTokens);
  }
  
  // è®¡ç®—æˆæœ¬
  private calculateCost(model: string, tokens: number): number {
    const pricing: Record<string, number> = {
      'gpt-4': 0.03 / 1000, // $0.03 per 1K tokens
      'gpt-3.5-turbo': 0.002 / 1000, // $0.002 per 1K tokens
    };
    
    return (pricing[model] || 0) * tokens;
  }
  
  // æ£€æŸ¥å¼‚å¸¸ä½¿ç”¨
  private async checkAnomalousUsage(
    userId: string,
    tokens: number
  ): Promise<void> {
    // è·å–ç”¨æˆ·æœ€è¿‘çš„å¹³å‡ä½¿ç”¨é‡
    const avgUsage = await this.getAverageUsage(userId);
    
    // å¦‚æœå½“å‰ä½¿ç”¨é‡è¶…è¿‡å¹³å‡å€¼çš„3å€
    if (tokens > avgUsage * 3) {
      await this.sendAlert({
        type: 'anomalous_usage',
        userId,
        tokens,
        avgUsage,
      });
    }
  }
  
  // è·å–ç”¨æˆ·ç»Ÿè®¡
  async getUserStats(userId: string, period: 'day' | 'month' = 'day') {
    const startDate = period === 'day'
      ? new Date(Date.now() - 24 * 60 * 60 * 1000)
      : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    
    const stats = await db
      .select({
        totalTokens: sum(tokenUsage.totalTokens),
        totalCost: sum(tokenUsage.cost),
        requestCount: count(),
      })
      .from(tokenUsage)
      .where(
        and(
          eq(tokenUsage.userId, userId),
          gte(tokenUsage.timestamp, startDate)
        )
      );
    
    return stats[0];
  }
}

export const tokenMonitor = new TokenMonitor();
```

### 3. æˆæœ¬é¢„è­¦ç³»ç»Ÿ

```typescript
// src/lib/monitoring/cost-alert.ts
export class CostAlertSystem {
  private thresholds = {
    daily: 100, // $100/å¤©
    monthly: 2000, // $2000/æœˆ
    perUser: 50, // $50/ç”¨æˆ·/æœˆ
  };
  
  async checkCostThresholds(): Promise<void> {
    // æ£€æŸ¥æ¯æ—¥æˆæœ¬
    const dailyCost = await this.getDailyCost();
    if (dailyCost > this.thresholds.daily) {
      await this.sendAlert('daily_threshold_exceeded', {
        cost: dailyCost,
        threshold: this.thresholds.daily,
      });
    }
    
    // æ£€æŸ¥æœˆåº¦æˆæœ¬
    const monthlyCost = await this.getMonthlyCost();
    if (monthlyCost > this.thresholds.monthly) {
      await this.sendAlert('monthly_threshold_exceeded', {
        cost: monthlyCost,
        threshold: this.thresholds.monthly,
      });
    }
    
    // æ£€æŸ¥å¼‚å¸¸ç”¨æˆ·
    const anomalousUsers = await this.getAnomalousUsers();
    if (anomalousUsers.length > 0) {
      await this.sendAlert('anomalous_users', {
        users: anomalousUsers,
      });
    }
  }
  
  private async getDailyCost(): Promise<number> {
    const startDate = new Date(Date.now() - 24 * 60 * 60 * 1000);
    
    const result = await db
      .select({ total: sum(tokenUsage.cost) })
      .from(tokenUsage)
      .where(gte(tokenUsage.timestamp, startDate));
    
    return result[0]?.total || 0;
  }
  
  private async sendAlert(type: string, data: any): Promise<void> {
    // å‘é€åˆ° Slack
    await fetch(process.env.SLACK_WEBHOOK_URL!, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: `ğŸš¨ æˆæœ¬å‘Šè­¦: ${type}`,
        attachments: [{
          color: 'danger',
          fields: Object.entries(data).map(([key, value]) => ({
            title: key,
            value: String(value),
            short: true,
          })),
        }],
      }),
    });
    
    // å‘é€é‚®ä»¶ç»™ç®¡ç†å‘˜
    await mailService.send({
      to: process.env.ADMIN_EMAIL!,
      subject: `æˆæœ¬å‘Šè­¦: ${type}`,
      template: 'cost-alert',
      data: { type, ...data },
    });
  }
}
```

## å››ã€æ”¯ä»˜å®‰å…¨

### 1. Stripe Webhook éªŒè¯

```typescript
// src/app/api/webhooks/stripe/route.ts
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2023-10-16',
});

export async function POST(req: NextRequest) {
  const body = await req.text();
  const signature = req.headers.get('stripe-signature');
  
  if (!signature) {
    return new NextResponse('No signature', { status: 400 });
  }
  
  let event: Stripe.Event;
  
  try {
    // éªŒè¯ Webhook ç­¾å
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (error) {
    console.error('Webhook signature verification failed:', error);
    return new NextResponse('Invalid signature', { status: 400 });
  }
  
  // å¹‚ç­‰æ€§æ£€æŸ¥
  const existingEvent = await db.query.stripeEvents.findFirst({
    where: eq(stripeEvents.eventId, event.id),
  });
  
  if (existingEvent) {
    console.log('Event already processed:', event.id);
    return NextResponse.json({ received: true });
  }
  
  // è®°å½•äº‹ä»¶
  await db.insert(stripeEvents).values({
    eventId: event.id,
    type: event.type,
    processed: false,
  });
  
  try {
    // å¤„ç†äº‹ä»¶
    await handleStripeEvent(event);
    
    // æ ‡è®°ä¸ºå·²å¤„ç†
    await db.update(stripeEvents)
      .set({ processed: true })
      .where(eq(stripeEvents.eventId, event.id));
    
    return NextResponse.json({ received: true });
  } catch (error) {
    console.error('Error processing webhook:', error);
    
    // è®°å½•é”™è¯¯
    await db.update(stripeEvents)
      .set({ error: error.message })
      .where(eq(stripeEvents.eventId, event.id));
    
    return new NextResponse('Processing failed', { status: 500 });
  }
}
```


### 2. æ”¯ä»˜é‡‘é¢éªŒè¯

```typescript
// src/lib/payment/validation.ts
export class PaymentValidator {
  // éªŒè¯æ”¯ä»˜é‡‘é¢
  async validatePaymentAmount(
    sessionId: string,
    expectedAmount: number
  ): Promise<boolean> {
    const session = await stripe.checkout.sessions.retrieve(sessionId);
    
    // éªŒè¯é‡‘é¢
    if (session.amount_total !== expectedAmount) {
      await this.logSecurityEvent({
        type: 'payment_amount_mismatch',
        sessionId,
        expected: expectedAmount,
        actual: session.amount_total,
      });
      
      return false;
    }
    
    // éªŒè¯è´§å¸
    if (session.currency !== 'usd') {
      await this.logSecurityEvent({
        type: 'payment_currency_mismatch',
        sessionId,
        currency: session.currency,
      });
      
      return false;
    }
    
    return true;
  }
  
  // é˜²æ­¢é‡å¤æ”¯ä»˜
  async checkDuplicatePayment(
    userId: string,
    amount: number
  ): Promise<boolean> {
    // æ£€æŸ¥æœ€è¿‘5åˆ†é’Ÿå†…æ˜¯å¦æœ‰ç›¸åŒé‡‘é¢çš„æ”¯ä»˜
    const recentPayment = await db.query.payments.findFirst({
      where: and(
        eq(payments.userId, userId),
        eq(payments.amount, amount),
        gte(payments.createdAt, new Date(Date.now() - 5 * 60 * 1000))
      ),
    });
    
    if (recentPayment) {
      await this.logSecurityEvent({
        type: 'duplicate_payment_attempt',
        userId,
        amount,
        previousPaymentId: recentPayment.id,
      });
      
      return true; // æ˜¯é‡å¤æ”¯ä»˜
    }
    
    return false;
  }
  
  // æ£€æµ‹å¼‚å¸¸æ”¯ä»˜æ¨¡å¼
  async detectAnomalousPayment(
    userId: string,
    amount: number
  ): Promise<boolean> {
    // è·å–ç”¨æˆ·å†å²æ”¯ä»˜
    const history = await db.query.payments.findMany({
      where: eq(payments.userId, userId),
      orderBy: desc(payments.createdAt),
      limit: 10,
    });
    
    if (history.length === 0) {
      return false; // é¦–æ¬¡æ”¯ä»˜ï¼Œä¸ç®—å¼‚å¸¸
    }
    
    // è®¡ç®—å¹³å‡æ”¯ä»˜é‡‘é¢
    const avgAmount = history.reduce((sum, p) => sum + p.amount, 0) / history.length;
    
    // å¦‚æœå½“å‰é‡‘é¢è¶…è¿‡å¹³å‡å€¼çš„5å€
    if (amount > avgAmount * 5) {
      await this.logSecurityEvent({
        type: 'anomalous_payment_amount',
        userId,
        amount,
        avgAmount,
      });
      
      // å‘é€éªŒè¯é‚®ä»¶
      await this.sendPaymentVerificationEmail(userId, amount);
      
      return true;
    }
    
    return false;
  }
}

export const paymentValidator = new PaymentValidator();
```

### 3. é€€æ¬¾é˜²æŠ¤

```typescript
// src/lib/payment/refund-protection.ts
export class RefundProtection {
  // æ£€æŸ¥é€€æ¬¾è¯·æ±‚
  async validateRefundRequest(
    paymentId: string,
    userId: string
  ): Promise<{ allowed: boolean; reason?: string }> {
    const payment = await db.query.payments.findFirst({
      where: eq(payments.id, paymentId),
    });
    
    if (!payment) {
      return { allowed: false, reason: 'æ”¯ä»˜è®°å½•ä¸å­˜åœ¨' };
    }
    
    // éªŒè¯ç”¨æˆ·
    if (payment.userId !== userId) {
      await this.logSecurityEvent({
        type: 'unauthorized_refund_attempt',
        paymentId,
        userId,
        actualUserId: payment.userId,
      });
      
      return { allowed: false, reason: 'æ— æƒé™' };
    }
    
    // æ£€æŸ¥æ”¯ä»˜æ—¶é—´ï¼ˆ30å¤©å†…å¯é€€æ¬¾ï¼‰
    const daysSincePayment = 
      (Date.now() - payment.createdAt.getTime()) / (1000 * 60 * 60 * 24);
    
    if (daysSincePayment > 30) {
      return { allowed: false, reason: 'è¶…è¿‡é€€æ¬¾æœŸé™' };
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²é€€æ¬¾
    if (payment.refunded) {
      return { allowed: false, reason: 'å·²é€€æ¬¾' };
    }
    
    // æ£€æŸ¥é€€æ¬¾é¢‘ç‡
    const recentRefunds = await db.query.refunds.findMany({
      where: and(
        eq(refunds.userId, userId),
        gte(refunds.createdAt, new Date(Date.now() - 30 * 24 * 60 * 60 * 1000))
      ),
    });
    
    if (recentRefunds.length >= 3) {
      await this.logSecurityEvent({
        type: 'excessive_refund_requests',
        userId,
        count: recentRefunds.length,
      });
      
      return { allowed: false, reason: 'é€€æ¬¾æ¬¡æ•°è¿‡å¤š' };
    }
    
    return { allowed: true };
  }
  
  // å¤„ç†é€€æ¬¾
  async processRefund(paymentId: string, reason: string): Promise<void> {
    const payment = await db.query.payments.findFirst({
      where: eq(payments.id, paymentId),
    });
    
    if (!payment) {
      throw new Error('Payment not found');
    }
    
    try {
      // è°ƒç”¨ Stripe é€€æ¬¾
      const refund = await stripe.refunds.create({
        payment_intent: payment.stripePaymentIntentId,
        reason: 'requested_by_customer',
      });
      
      // è®°å½•é€€æ¬¾
      await db.insert(refunds).values({
        paymentId,
        userId: payment.userId,
        amount: payment.amount,
        reason,
        stripeRefundId: refund.id,
      });
      
      // æ›´æ–°æ”¯ä»˜çŠ¶æ€
      await db.update(payments)
        .set({ refunded: true })
        .where(eq(payments.id, paymentId));
      
      // æ‰£é™¤ç§¯åˆ†
      await deductCredits(payment.userId, payment.credits);
      
      // å‘é€é€šçŸ¥
      await mailService.send({
        to: payment.email,
        subject: 'é€€æ¬¾æˆåŠŸ',
        template: 'refund-success',
        data: {
          amount: payment.amount,
          refundId: refund.id,
        },
      });
    } catch (error) {
      console.error('Refund failed:', error);
      throw error;
    }
  }
}
```

## äº”ã€æ•°æ®å®‰å…¨

### 1. æ•æ„Ÿæ•°æ®åŠ å¯†

```typescript
// src/lib/security/encryption.ts
import { createCipheriv, createDecipheriv, randomBytes, scryptSync } from 'crypto';

export class EncryptionService {
  private algorithm = 'aes-256-gcm';
  private key: Buffer;
  
  constructor() {
    // ä»ç¯å¢ƒå˜é‡æ´¾ç”Ÿå¯†é’¥
    this.key = scryptSync(
      process.env.ENCRYPTION_KEY!,
      'salt',
      32
    );
  }
  
  // åŠ å¯†
  encrypt(text: string): string {
    const iv = randomBytes(16);
    const cipher = createCipheriv(this.algorithm, this.key, iv);
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    // è¿”å› iv:authTag:encrypted
    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
  }
  
  // è§£å¯†
  decrypt(encryptedText: string): string {
    const [ivHex, authTagHex, encrypted] = encryptedText.split(':');
    
    const iv = Buffer.from(ivHex, 'hex');
    const authTag = Buffer.from(authTagHex, 'hex');
    
    const decipher = createDecipheriv(this.algorithm, this.key, iv);
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
  
  // åŠ å¯†æ•æ„Ÿå­—æ®µ
  async encryptSensitiveData(data: any): Promise<any> {
    const sensitiveFields = ['email', 'phone', 'address', 'ssn'];
    
    const encrypted = { ...data };
    
    for (const field of sensitiveFields) {
      if (encrypted[field]) {
        encrypted[field] = this.encrypt(encrypted[field]);
      }
    }
    
    return encrypted;
  }
}

export const encryptionService = new EncryptionService();
```

### 2. SQL æ³¨å…¥é˜²æŠ¤

```typescript
// âœ… ä½¿ç”¨ Drizzle ORMï¼ˆè‡ªåŠ¨é˜²æŠ¤ï¼‰
const user = await db.query.users.findFirst({
  where: eq(users.email, userInput), // è‡ªåŠ¨å‚æ•°åŒ–
});

// âœ… ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
const result = await db.execute(
  sql`SELECT * FROM users WHERE email = ${userInput}`
);

// âŒ æ°¸è¿œä¸è¦è¿™æ ·åš
const result = await db.execute(
  sql.raw(`SELECT * FROM users WHERE email = '${userInput}'`)
);
```

### 3. XSS é˜²æŠ¤

```typescript
// src/lib/security/xss-protection.ts
import DOMPurify from 'isomorphic-dompurify';

export class XSSProtection {
  // æ¸…ç† HTML
  sanitizeHTML(html: string): string {
    return DOMPurify.sanitize(html, {
      ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'a', 'ul', 'ol', 'li'],
      ALLOWED_ATTR: ['href', 'target'],
    });
  }
  
  // è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦
  escapeHTML(text: string): string {
    const map: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;',
    };
    
    return text.replace(/[&<>"'/]/g, (char) => map[char]);
  }
  
  // éªŒè¯ URL
  isValidURL(url: string): boolean {
    try {
      const parsed = new URL(url);
      return ['http:', 'https:'].includes(parsed.protocol);
    } catch {
      return false;
    }
  }
}

export const xssProtection = new XSSProtection();

// ä½¿ç”¨ç¤ºä¾‹
// src/components/user-content.tsx
export function UserContent({ content }: { content: string }) {
  const sanitized = xssProtection.sanitizeHTML(content);
  
  return (
    <div dangerouslySetInnerHTML={{ __html: sanitized }} />
  );
}
```

### 4. CSRF é˜²æŠ¤

```typescript
// src/lib/security/csrf.ts
import { randomBytes } from 'crypto';

export class CSRFProtection {
  // ç”Ÿæˆ CSRF Token
  generateToken(): string {
    return randomBytes(32).toString('hex');
  }
  
  // éªŒè¯ CSRF Token
  async verifyToken(token: string, sessionId: string): Promise<boolean> {
    const storedToken = await redis.get(`csrf:${sessionId}`);
    
    if (!storedToken || storedToken !== token) {
      return false;
    }
    
    // åˆ é™¤å·²ä½¿ç”¨çš„ tokenï¼ˆä¸€æ¬¡æ€§ï¼‰
    await redis.del(`csrf:${sessionId}`);
    
    return true;
  }
  
  // å­˜å‚¨ CSRF Token
  async storeToken(token: string, sessionId: string): Promise<void> {
    await redis.setex(`csrf:${sessionId}`, 3600, token); // 1å°æ—¶æœ‰æ•ˆ
  }
}

export const csrfProtection = new CSRFProtection();

// ä¸­é—´ä»¶
export async function csrfMiddleware(req: NextRequest) {
  if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(req.method)) {
    const token = req.headers.get('x-csrf-token');
    const sessionId = req.cookies.get('sessionId')?.value;
    
    if (!token || !sessionId) {
      return new NextResponse('Missing CSRF token', { status: 403 });
    }
    
    const isValid = await csrfProtection.verifyToken(token, sessionId);
    
    if (!isValid) {
      return new NextResponse('Invalid CSRF token', { status: 403 });
    }
  }
  
  return null;
}
```

## å…­ã€è®¿é—®æ§åˆ¶

### 1. åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ï¼ˆRBACï¼‰

```typescript
// src/lib/auth/rbac.ts
export enum Role {
  USER = 'user',
  PREMIUM = 'premium',
  ADMIN = 'admin',
}

export enum Permission {
  READ_CONTENT = 'read:content',
  WRITE_CONTENT = 'write:content',
  DELETE_CONTENT = 'delete:content',
  USE_AI = 'use:ai',
  MANAGE_USERS = 'manage:users',
  VIEW_ANALYTICS = 'view:analytics',
}

const rolePermissions: Record<Role, Permission[]> = {
  [Role.USER]: [
    Permission.READ_CONTENT,
    Permission.WRITE_CONTENT,
  ],
  [Role.PREMIUM]: [
    Permission.READ_CONTENT,
    Permission.WRITE_CONTENT,
    Permission.USE_AI,
  ],
  [Role.ADMIN]: Object.values(Permission),
};

export class RBACService {
  // æ£€æŸ¥æƒé™
  hasPermission(role: Role, permission: Permission): boolean {
    return rolePermissions[role]?.includes(permission) ?? false;
  }
  
  // æ£€æŸ¥å¤šä¸ªæƒé™
  hasAllPermissions(role: Role, permissions: Permission[]): boolean {
    return permissions.every(p => this.hasPermission(role, p));
  }
  
  // æ£€æŸ¥ä»»ä¸€æƒé™
  hasAnyPermission(role: Role, permissions: Permission[]): boolean {
    return permissions.some(p => this.hasPermission(role, p));
  }
}

export const rbac = new RBACService();

// æƒé™ä¸­é—´ä»¶
export function requirePermission(permission: Permission) {
  return async (req: NextRequest) => {
    const session = await auth();
    
    if (!session?.user) {
      return new NextResponse('Unauthorized', { status: 401 });
    }
    
    if (!rbac.hasPermission(session.user.role, permission)) {
      return new NextResponse('Forbidden', { status: 403 });
    }
    
    return null;
  };
}
```

### 2. èµ„æºçº§æƒé™æ§åˆ¶

```typescript
// src/lib/auth/resource-access.ts
export class ResourceAccessControl {
  // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ä»¥è®¿é—®èµ„æº
  async canAccess(
    userId: string,
    resourceType: string,
    resourceId: string,
    action: 'read' | 'write' | 'delete'
  ): Promise<boolean> {
    // 1. æ£€æŸ¥èµ„æºæ‰€æœ‰æƒ
    const resource = await this.getResource(resourceType, resourceId);
    
    if (!resource) {
      return false;
    }
    
    if (resource.userId === userId) {
      return true; // æ‰€æœ‰è€…æœ‰å…¨éƒ¨æƒé™
    }
    
    // 2. æ£€æŸ¥å…±äº«æƒé™
    const sharedAccess = await db.query.resourceSharing.findFirst({
      where: and(
        eq(resourceSharing.resourceType, resourceType),
        eq(resourceSharing.resourceId, resourceId),
        eq(resourceSharing.userId, userId)
      ),
    });
    
    if (sharedAccess) {
      return this.checkSharedPermission(sharedAccess.permissions, action);
    }
    
    // 3. æ£€æŸ¥å…¬å¼€è®¿é—®
    if (action === 'read' && resource.isPublic) {
      return true;
    }
    
    return false;
  }
  
  private checkSharedPermission(
    permissions: string[],
    action: string
  ): boolean {
    return permissions.includes(action) || permissions.includes('*');
  }
}

export const resourceAccess = new ResourceAccessControl();
```

## ä¸ƒã€å®‰å…¨ç›‘æ§ä¸å®¡è®¡

### 1. å®‰å…¨äº‹ä»¶æ—¥å¿—

```typescript
// src/lib/security/audit-log.ts
export class AuditLogger {
  async log(event: {
    type: string;
    userId?: string;
    ip?: string;
    userAgent?: string;
    resource?: string;
    action?: string;
    result: 'success' | 'failure';
    details?: any;
  }): Promise<void> {
    await db.insert(auditLogs).values({
      ...event,
      timestamp: new Date(),
    });
    
    // å¦‚æœæ˜¯å®‰å…¨äº‹ä»¶ï¼Œå‘é€å‘Šè­¦
    if (this.isSecurityEvent(event.type)) {
      await this.sendSecurityAlert(event);
    }
  }
  
  private isSecurityEvent(type: string): boolean {
    const securityEvents = [
      'unauthorized_access',
      'failed_login',
      'suspicious_activity',
      'rate_limit_exceeded',
      'invalid_token',
    ];
    
    return securityEvents.includes(type);
  }
  
  private async sendSecurityAlert(event: any): Promise<void> {
    // å‘é€åˆ°å®‰å…¨å›¢é˜Ÿ
    await fetch(process.env.SECURITY_WEBHOOK_URL!, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: `ğŸ”’ å®‰å…¨äº‹ä»¶: ${event.type}`,
        event,
      }),
    });
  }
}

export const auditLogger = new AuditLogger();
```

### 2. å¼‚å¸¸è¡Œä¸ºæ£€æµ‹

```typescript
// src/lib/security/anomaly-detection.ts
export class AnomalyDetector {
  // æ£€æµ‹å¼‚å¸¸ç™»å½•
  async detectAnomalousLogin(
    userId: string,
    ip: string,
    userAgent: string
  ): Promise<boolean> {
    // è·å–ç”¨æˆ·å†å²ç™»å½•è®°å½•
    const history = await db.query.loginHistory.findMany({
      where: eq(loginHistory.userId, userId),
      orderBy: desc(loginHistory.timestamp),
      limit: 10,
    });
    
    if (history.length === 0) {
      return false; // é¦–æ¬¡ç™»å½•
    }
    
    // æ£€æŸ¥ IP åœ°å€
    const knownIPs = new Set(history.map(h => h.ip));
    if (!knownIPs.has(ip)) {
      // æ–° IP åœ°å€
      await this.sendLoginAlert(userId, ip, 'new_ip');
      return true;
    }
    
    // æ£€æŸ¥è®¾å¤‡
    const knownDevices = new Set(history.map(h => h.userAgent));
    if (!knownDevices.has(userAgent)) {
      // æ–°è®¾å¤‡
      await this.sendLoginAlert(userId, ip, 'new_device');
      return true;
    }
    
    // æ£€æŸ¥ç™»å½•é¢‘ç‡
    const recentLogins = history.filter(h => 
      Date.now() - h.timestamp.getTime() < 60 * 60 * 1000 // 1å°æ—¶å†…
    );
    
    if (recentLogins.length > 5) {
      // é¢‘ç¹ç™»å½•
      await this.sendLoginAlert(userId, ip, 'frequent_login');
      return true;
    }
    
    return false;
  }
  
  private async sendLoginAlert(
    userId: string,
    ip: string,
    reason: string
  ): Promise<void> {
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId),
    });
    
    if (!user) return;
    
    await mailService.send({
      to: user.email,
      subject: 'å¼‚å¸¸ç™»å½•æ£€æµ‹',
      template: 'anomalous-login',
      data: {
        ip,
        reason,
        timestamp: new Date(),
      },
    });
  }
}

export const anomalyDetector = new AnomalyDetector();
```

## å…«ã€å®‰å…¨é…ç½®æ¸…å•

### 1. ç¯å¢ƒå˜é‡å®‰å…¨

```bash
# âœ… å¿…é¡»é…ç½®çš„å®‰å…¨ç›¸å…³ç¯å¢ƒå˜é‡

# åŠ å¯†å¯†é’¥ï¼ˆè‡³å°‘32å­—ç¬¦ï¼‰
ENCRYPTION_KEY=your-very-long-and-random-encryption-key

# JWT å¯†é’¥
JWT_SECRET=your-jwt-secret-key

# Webhook å¯†é’¥
STRIPE_WEBHOOK_SECRET=whsec_xxxxx

# CSRF å¯†é’¥
CSRF_SECRET=your-csrf-secret

# ç®¡ç†å‘˜é‚®ç®±
ADMIN_EMAIL=admin@example.com

# å®‰å…¨å‘Šè­¦ Webhook
SECURITY_WEBHOOK_URL=https://hooks.slack.com/services/xxx
```

### 2. Next.js å®‰å…¨é…ç½®

```typescript
// next.config.js
module.exports = {
  // å®‰å…¨å¤´
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'X-DNS-Prefetch-Control',
            value: 'on',
          },
          {
            key: 'Strict-Transport-Security',
            value: 'max-age=63072000; includeSubDomains; preload',
          },
          {
            key: 'X-Frame-Options',
            value: 'SAMEORIGIN',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'X-XSS-Protection',
            value: '1; mode=block',
          },
          {
            key: 'Referrer-Policy',
            value: 'strict-origin-when-cross-origin',
          },
          {
            key: 'Permissions-Policy',
            value: 'camera=(), microphone=(), geolocation=()',
          },
        ],
      },
    ];
  },
};
```

## æ€»ç»“

MkSaaS çš„å®‰å…¨é˜²æŠ¤ä½“ç³»åŒ…æ‹¬ï¼š

1. **API å¯†é’¥å®‰å…¨**: æœåŠ¡ç«¯ä»£ç†ã€å¯†é’¥è½®æ¢ã€ç¯å¢ƒå˜é‡ç®¡ç†
2. **API æ»¥ç”¨é˜²æŠ¤**: å¤šå±‚é€Ÿç‡é™åˆ¶ã€Token ç›‘æ§ã€æˆæœ¬é¢„è­¦
3. **æ”¯ä»˜å®‰å…¨**: Webhook éªŒè¯ã€é‡‘é¢éªŒè¯ã€é€€æ¬¾é˜²æŠ¤
4. **æ•°æ®å®‰å…¨**: åŠ å¯†å­˜å‚¨ã€SQL æ³¨å…¥é˜²æŠ¤ã€XSS/CSRF é˜²æŠ¤
5. **è®¿é—®æ§åˆ¶**: RBACã€èµ„æºçº§æƒé™ã€å®¡è®¡æ—¥å¿—
6. **ç›‘æ§å‘Šè­¦**: å¼‚å¸¸æ£€æµ‹ã€å®‰å…¨äº‹ä»¶æ—¥å¿—ã€å®æ—¶å‘Šè­¦

å»ºè®®å®šæœŸè¿›è¡Œå®‰å…¨å®¡è®¡å’Œæ¸—é€æµ‹è¯•ï¼ŒæŒç»­æ”¹è¿›å®‰å…¨æªæ–½ã€‚
