# é—®é¢˜21ï¼šé‚®ä»¶å‘é€åŠŸèƒ½çš„è®¾è®¡ã€ä¸»è¦èƒ½åŠ›å’Œä»·å€¼å¤„ç†

## æ¦‚è¿°

MkSaaS çš„é‚®ä»¶ç³»ç»Ÿæ˜¯ç”¨æˆ·é€šçŸ¥å’Œè¥é”€çš„æ ¸å¿ƒç»„ä»¶ï¼Œæä¾›äº‹åŠ¡æ€§é‚®ä»¶ã€è¥é”€é‚®ä»¶ã€è‡ªåŠ¨åŒ–é‚®ä»¶ç­‰å¤šç§åŠŸèƒ½ã€‚æœ¬æ–‡è¯¦ç»†ä»‹ç»é‚®ä»¶ç³»ç»Ÿçš„æ¶æ„è®¾è®¡ã€æ ¸å¿ƒèƒ½åŠ›å’Œæœ€ä½³å®è·µã€‚

## ä¸€ã€é‚®ä»¶ç³»ç»Ÿæ¶æ„

### 1. æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   åº”ç”¨å±‚    â”‚ (è§¦å‘é‚®ä»¶å‘é€)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚  é‚®ä»¶æœåŠ¡   â”‚ (é‚®ä»¶é€»è¾‘å¤„ç†)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚  é‚®ä»¶é˜Ÿåˆ—   â”‚ (å¼‚æ­¥å¤„ç†)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚ é‚®ä»¶æä¾›å•†  â”‚ (å®é™…å‘é€)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ ¸å¿ƒç»„ä»¶

```typescript
// src/lib/mail/index.ts
export interface MailService {
  // äº‹åŠ¡æ€§é‚®ä»¶
  sendTransactional(email: TransactionalEmail): Promise<EmailResult>;
  
  // è¥é”€é‚®ä»¶
  sendMarketing(email: MarketingEmail): Promise<EmailResult>;
  
  // æ‰¹é‡é‚®ä»¶
  sendBulk(emails: Email[]): Promise<EmailResult[]>;
  
  // æ¨¡æ¿é‚®ä»¶
  sendTemplate(templateId: string, data: any): Promise<EmailResult>;
  
  // è‡ªåŠ¨åŒ–é‚®ä»¶
  sendAutomated(trigger: string, userId: string): Promise<EmailResult>;
}
```

## äºŒã€é‚®ä»¶ç±»å‹ä¸åœºæ™¯

### 1. äº‹åŠ¡æ€§é‚®ä»¶

```typescript
// src/lib/mail/transactional.ts
export const transactionalEmails = {
  // ç”¨æˆ·æ³¨å†Œ
  async sendWelcome(user: User) {
    return mailService.send({
      to: user.email,
      subject: 'æ¬¢è¿åŠ å…¥ MkSaaS',
      template: 'welcome',
      data: {
        name: user.name,
        verifyUrl: generateVerifyUrl(user.id),
      },
      priority: 'high',
    });
  },
  
  // é‚®ç®±éªŒè¯
  async sendVerification(user: User) {
    const token = await generateVerificationToken(user.id);
    
    return mailService.send({
      to: user.email,
      subject: 'éªŒè¯ä½ çš„é‚®ç®±',
      template: 'email-verification',
      data: {
        name: user.name,
        verifyUrl: `${process.env.NEXT_PUBLIC_APP_URL}/verify?token=${token}`,
        expiresIn: '24å°æ—¶',
      },
      priority: 'high',
    });
  },
  
  // å¯†ç é‡ç½®
  async sendPasswordReset(user: User) {
    const token = await generateResetToken(user.id);
    
    return mailService.send({
      to: user.email,
      subject: 'é‡ç½®ä½ çš„å¯†ç ',
      template: 'password-reset',
      data: {
        name: user.name,
        resetUrl: `${process.env.NEXT_PUBLIC_APP_URL}/reset-password?token=${token}`,
        expiresIn: '1å°æ—¶',
      },
      priority: 'high',
    });
  },
  
  // è®¢å•ç¡®è®¤
  async sendOrderConfirmation(order: Order) {
    return mailService.send({
      to: order.email,
      subject: `è®¢å•ç¡®è®¤ #${order.id}`,
      template: 'order-confirmation',
      data: {
        orderId: order.id,
        items: order.items,
        total: order.total,
        orderUrl: `${process.env.NEXT_PUBLIC_APP_URL}/orders/${order.id}`,
      },
      priority: 'high',
    });
  },
  
  // æ”¯ä»˜æˆåŠŸ
  async sendPaymentSuccess(payment: Payment) {
    return mailService.send({
      to: payment.email,
      subject: 'æ”¯ä»˜æˆåŠŸ',
      template: 'payment-success',
      data: {
        amount: payment.amount,
        currency: payment.currency,
        receiptUrl: payment.receiptUrl,
        invoiceUrl: payment.invoiceUrl,
      },
      priority: 'high',
    });
  },
  
  // è®¢é˜…ç¡®è®¤
  async sendSubscriptionConfirmation(subscription: Subscription) {
    return mailService.send({
      to: subscription.email,
      subject: 'è®¢é˜…ç¡®è®¤',
      template: 'subscription-confirmation',
      data: {
        plan: subscription.plan,
        amount: subscription.amount,
        nextBillingDate: subscription.nextBillingDate,
        manageUrl: `${process.env.NEXT_PUBLIC_APP_URL}/settings/billing`,
      },
      priority: 'high',
    });
  },
};
```

### 2. è¥é”€é‚®ä»¶

```typescript
// src/lib/mail/marketing.ts
export const marketingEmails = {
  // äº§å“æ›´æ–°
  async sendProductUpdate(users: User[], update: ProductUpdate) {
    const emails = users.map(user => ({
      to: user.email,
      subject: update.title,
      template: 'product-update',
      data: {
        name: user.name,
        title: update.title,
        content: update.content,
        imageUrl: update.imageUrl,
        ctaText: update.ctaText,
        ctaUrl: update.ctaUrl,
      },
      tags: ['marketing', 'product-update'],
    }));
    
    return mailService.sendBulk(emails);
  },
  
  // ä¿ƒé”€æ´»åŠ¨
  async sendPromotion(segment: UserSegment, promotion: Promotion) {
    const users = await getUsersBySegment(segment);
    
    const emails = users.map(user => ({
      to: user.email,
      subject: promotion.subject,
      template: 'promotion',
      data: {
        name: user.name,
        title: promotion.title,
        description: promotion.description,
        discount: promotion.discount,
        code: promotion.code,
        expiresAt: promotion.expiresAt,
        ctaUrl: `${process.env.NEXT_PUBLIC_APP_URL}/pricing?promo=${promotion.code}`,
      },
      tags: ['marketing', 'promotion'],
    }));
    
    return mailService.sendBulk(emails);
  },
  
  // æ–°åŠŸèƒ½ä»‹ç»
  async sendFeatureAnnouncement(users: User[], feature: Feature) {
    const emails = users.map(user => ({
      to: user.email,
      subject: `æ–°åŠŸèƒ½ï¼š${feature.name}`,
      template: 'feature-announcement',
      data: {
        name: user.name,
        featureName: feature.name,
        description: feature.description,
        benefits: feature.benefits,
        demoUrl: feature.demoUrl,
        docsUrl: feature.docsUrl,
      },
      tags: ['marketing', 'feature'],
    }));
    
    return mailService.sendBulk(emails);
  },
};
```

### 3. è‡ªåŠ¨åŒ–é‚®ä»¶

```typescript
// src/lib/mail/automated.ts
export const automatedEmails = {
  // æ¬¢è¿ç³»åˆ—é‚®ä»¶
  async sendWelcomeSeries(userId: string) {
    const user = await getUserById(userId);
    
    // Day 0: æ¬¢è¿é‚®ä»¶
    await mailService.send({
      to: user.email,
      subject: 'æ¬¢è¿åŠ å…¥ MkSaaS',
      template: 'welcome-day-0',
      data: { name: user.name },
      scheduledAt: new Date(),
    });
    
    // Day 1: å¿«é€Ÿå…¥é—¨
    await mailService.send({
      to: user.email,
      subject: 'å¿«é€Ÿå…¥é—¨æŒ‡å—',
      template: 'welcome-day-1',
      data: { name: user.name },
      scheduledAt: addDays(new Date(), 1),
    });
    
    // Day 3: åŠŸèƒ½ä»‹ç»
    await mailService.send({
      to: user.email,
      subject: 'æ¢ç´¢æ›´å¤šåŠŸèƒ½',
      template: 'welcome-day-3',
      data: { name: user.name },
      scheduledAt: addDays(new Date(), 3),
    });
    
    // Day 7: è·å–å¸®åŠ©
    await mailService.send({
      to: user.email,
      subject: 'éœ€è¦å¸®åŠ©å—ï¼Ÿ',
      template: 'welcome-day-7',
      data: { name: user.name },
      scheduledAt: addDays(new Date(), 7),
    });
  },
  
  // ç”¨æˆ·æ¿€æ´»æé†’
  async sendActivationReminder(userId: string) {
    const user = await getUserById(userId);
    
    if (!user.emailVerified) {
      await mailService.send({
        to: user.email,
        subject: 'è¯·éªŒè¯ä½ çš„é‚®ç®±',
        template: 'activation-reminder',
        data: {
          name: user.name,
          verifyUrl: generateVerifyUrl(user.id),
        },
      });
    }
  },
  
  // è®¢é˜…åˆ°æœŸæé†’
  async sendSubscriptionExpiring(userId: string) {
    const user = await getUserById(userId);
    const subscription = await getSubscription(userId);
    
    if (subscription && isExpiringSoon(subscription)) {
      await mailService.send({
        to: user.email,
        subject: 'ä½ çš„è®¢é˜…å³å°†åˆ°æœŸ',
        template: 'subscription-expiring',
        data: {
          name: user.name,
          plan: subscription.plan,
          expiresAt: subscription.expiresAt,
          renewUrl: `${process.env.NEXT_PUBLIC_APP_URL}/settings/billing`,
        },
      });
    }
  },
  
  // ç”¨æˆ·æµå¤±æŒ½å›
  async sendWinbackCampaign(userId: string) {
    const user = await getUserById(userId);
    const lastActivity = await getLastActivity(userId);
    
    if (isInactive(lastActivity, 30)) {
      await mailService.send({
        to: user.email,
        subject: 'æˆ‘ä»¬æƒ³å¿µä½ äº†',
        template: 'winback',
        data: {
          name: user.name,
          discount: '20%',
          ctaUrl: `${process.env.NEXT_PUBLIC_APP_URL}?promo=COMEBACK20`,
        },
      });
    }
  },
};
```

## ä¸‰ã€é‚®ä»¶æ¨¡æ¿ç³»ç»Ÿ

### 1. React Email æ¨¡æ¿

```typescript
// src/mail/templates/welcome.tsx
import {
  Html,
  Head,
  Body,
  Container,
  Section,
  Text,
  Button,
  Img,
  Hr,
} from '@react-email/components';

interface WelcomeEmailProps {
  name: string;
  verifyUrl: string;
}

export function WelcomeEmail({ name, verifyUrl }: WelcomeEmailProps) {
  return (
    <Html>
      <Head />
      <Body style={main}>
        <Container style={container}>
          <Img
            src="https://mksaas.me/logo.png"
            width="150"
            height="50"
            alt="MkSaaS"
            style={logo}
          />
          
          <Text style={heading}>æ¬¢è¿åŠ å…¥ MkSaaSï¼</Text>
          
          <Text style={paragraph}>
            ä½ å¥½ {name}ï¼Œ
          </Text>
          
          <Text style={paragraph}>
            æ„Ÿè°¢ä½ æ³¨å†Œ MkSaaSã€‚æˆ‘ä»¬å¾ˆé«˜å…´ä½ åŠ å…¥æˆ‘ä»¬çš„ç¤¾åŒºã€‚
          </Text>
          
          <Section style={buttonContainer}>
            <Button style={button} href={verifyUrl}>
              éªŒè¯é‚®ç®±
            </Button>
          </Section>
          
          <Text style={paragraph}>
            éªŒè¯åï¼Œä½ å°†å¯ä»¥ï¼š
          </Text>
          
          <ul style={list}>
            <li>è®¿é—®æ‰€æœ‰åŠŸèƒ½</li>
            <li>åˆ›å»ºå’Œç®¡ç†é¡¹ç›®</li>
            <li>è·å–æŠ€æœ¯æ”¯æŒ</li>
            <li>å‚ä¸ç¤¾åŒºè®¨è®º</li>
          </ul>
          
          <Hr style={hr} />
          
          <Text style={footer}>
            å¦‚æœä½ æ²¡æœ‰æ³¨å†Œ MkSaaSï¼Œè¯·å¿½ç•¥æ­¤é‚®ä»¶ã€‚
          </Text>
        </Container>
      </Body>
    </Html>
  );
}

// æ ·å¼å®šä¹‰
const main = {
  backgroundColor: '#f6f9fc',
  fontFamily: '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif',
};

const container = {
  backgroundColor: '#ffffff',
  margin: '0 auto',
  padding: '20px 0 48px',
  marginBottom: '64px',
  maxWidth: '600px',
};

const logo = {
  margin: '0 auto',
};

const heading = {
  fontSize: '32px',
  lineHeight: '1.3',
  fontWeight: '700',
  color: '#484848',
  padding: '17px 0 0',
};

const paragraph = {
  fontSize: '18px',
  lineHeight: '1.4',
  color: '#484848',
};

const buttonContainer = {
  padding: '27px 0',
};

const button = {
  backgroundColor: '#5469d4',
  borderRadius: '5px',
  color: '#fff',
  fontSize: '16px',
  fontWeight: 'bold',
  textDecoration: 'none',
  textAlign: 'center' as const,
  display: 'block',
  width: '100%',
  padding: '12px',
};

const list = {
  fontSize: '16px',
  lineHeight: '1.6',
  color: '#484848',
};

const hr = {
  borderColor: '#e6ebf1',
  margin: '20px 0',
};

const footer = {
  color: '#8898aa',
  fontSize: '12px',
  lineHeight: '16px',
};
```

### 2. æ¨¡æ¿ç®¡ç†

```typescript
// src/lib/mail/templates.ts
import { render } from '@react-email/render';
import { WelcomeEmail } from '@/mail/templates/welcome';
import { PasswordResetEmail } from '@/mail/templates/password-reset';
// ... å…¶ä»–æ¨¡æ¿

export const emailTemplates = {
  welcome: WelcomeEmail,
  'password-reset': PasswordResetEmail,
  'email-verification': EmailVerificationEmail,
  'order-confirmation': OrderConfirmationEmail,
  'payment-success': PaymentSuccessEmail,
  // ... æ›´å¤šæ¨¡æ¿
};

export function renderTemplate(
  templateId: string,
  data: any
): string {
  const Template = emailTemplates[templateId];
  
  if (!Template) {
    throw new Error(`Template ${templateId} not found`);
  }
  
  return render(<Template {...data} />);
}
```

## å››ã€é‚®ä»¶é˜Ÿåˆ—ä¸è°ƒåº¦

### 1. é˜Ÿåˆ—å®ç°

```typescript
// src/lib/mail/queue.ts
import { Queue, Worker } from 'bullmq';
import { Redis } from 'ioredis';

const redis = new Redis(process.env.REDIS_URL!);

// åˆ›å»ºé‚®ä»¶é˜Ÿåˆ—
export const emailQueue = new Queue('emails', {
  connection: redis,
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 1000,
    },
    removeOnComplete: {
      age: 24 * 3600, // 24å°æ—¶ååˆ é™¤
      count: 1000,
    },
    removeOnFail: {
      age: 7 * 24 * 3600, // 7å¤©ååˆ é™¤
    },
  },
});

// æ·»åŠ é‚®ä»¶åˆ°é˜Ÿåˆ—
export async function queueEmail(email: Email, options?: JobOptions) {
  return emailQueue.add('send-email', email, options);
}

// æ‰¹é‡æ·»åŠ é‚®ä»¶
export async function queueBulkEmails(emails: Email[]) {
  const jobs = emails.map((email, index) => ({
    name: 'send-email',
    data: email,
    opts: {
      delay: index * 100, // æ¯å°é‚®ä»¶å»¶è¿Ÿ100msï¼Œé¿å…é€Ÿç‡é™åˆ¶
    },
  }));
  
  return emailQueue.addBulk(jobs);
}

// Worker å¤„ç†é‚®ä»¶
const emailWorker = new Worker(
  'emails',
  async (job) => {
    const email = job.data as Email;
    
    console.log(`Sending email to ${email.to}`);
    
    const result = await emailProvider.send(email);
    
    // è®°å½•æ—¥å¿—
    await db.insert(emailLogs).values({
      to: email.to,
      subject: email.subject,
      template: email.template,
      status: result.success ? 'sent' : 'failed',
      error: result.error,
      messageId: result.id,
    });
    
    return result;
  },
  {
    connection: redis,
    concurrency: 10, // å¹¶å‘å¤„ç†10å°é‚®ä»¶
  }
);

// äº‹ä»¶ç›‘å¬
emailWorker.on('completed', (job, result) => {
  console.log(`Email ${job.id} sent successfully:`, result);
});

emailWorker.on('failed', (job, err) => {
  console.error(`Email ${job?.id} failed:`, err);
});
```


### 2. å®šæ—¶é‚®ä»¶

```typescript
// src/lib/mail/scheduler.ts
import { Queue } from 'bullmq';

// åˆ›å»ºå®šæ—¶é‚®ä»¶é˜Ÿåˆ—
export const scheduledEmailQueue = new Queue('scheduled-emails', {
  connection: redis,
});

// æ·»åŠ å®šæ—¶é‚®ä»¶
export async function scheduleEmail(
  email: Email,
  scheduledAt: Date
) {
  const delay = scheduledAt.getTime() - Date.now();
  
  if (delay < 0) {
    throw new Error('Scheduled time must be in the future');
  }
  
  return scheduledEmailQueue.add(
    'send-scheduled-email',
    email,
    { delay }
  );
}

// å–æ¶ˆå®šæ—¶é‚®ä»¶
export async function cancelScheduledEmail(jobId: string) {
  const job = await scheduledEmailQueue.getJob(jobId);
  if (job) {
    await job.remove();
  }
}
```

### 3. é‡å¤é‚®ä»¶

```typescript
// æ¯æ—¥æ‘˜è¦é‚®ä»¶
export async function scheduleDailyDigest() {
  await emailQueue.add(
    'daily-digest',
    {},
    {
      repeat: {
        pattern: '0 9 * * *', // æ¯å¤©æ—©ä¸Š9ç‚¹
        tz: 'Asia/Shanghai',
      },
    }
  );
}

// æ¯å‘¨æŠ¥å‘Š
export async function scheduleWeeklyReport() {
  await emailQueue.add(
    'weekly-report',
    {},
    {
      repeat: {
        pattern: '0 10 * * 1', // æ¯å‘¨ä¸€æ—©ä¸Š10ç‚¹
        tz: 'Asia/Shanghai',
      },
    }
  );
}
```

## äº”ã€é‚®ä»¶è¿½è¸ªä¸åˆ†æ

### 1. æ‰“å¼€è¿½è¸ª

```typescript
// src/lib/mail/tracking.ts
export function addOpenTracking(html: string, emailId: string): string {
  const trackingPixel = `<img src="${process.env.NEXT_PUBLIC_APP_URL}/api/track/open/${emailId}" width="1" height="1" alt="" />`;
  
  return html.replace('</body>', `${trackingPixel}</body>`);
}

// API è·¯ç”±
// src/app/api/track/open/[id]/route.ts
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  // è®°å½•æ‰“å¼€äº‹ä»¶
  await db.insert(emailEvents).values({
    emailId: params.id,
    event: 'opened',
    userAgent: req.headers.get('user-agent'),
    ip: req.ip,
  });
  
  // è¿”å›1x1é€æ˜å›¾ç‰‡
  const pixel = Buffer.from(
    'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
    'base64'
  );
  
  return new NextResponse(pixel, {
    headers: {
      'Content-Type': 'image/gif',
      'Cache-Control': 'no-cache, no-store, must-revalidate',
    },
  });
}
```

### 2. ç‚¹å‡»è¿½è¸ª

```typescript
export function addClickTracking(html: string, emailId: string): string {
  return html.replace(
    /href="(https?:\/\/[^"]+)"/g,
    (match, url) => {
      const trackingUrl = `${process.env.NEXT_PUBLIC_APP_URL}/api/track/click/${emailId}?url=${encodeURIComponent(url)}`;
      return `href="${trackingUrl}"`;
    }
  );
}

// API è·¯ç”±
// src/app/api/track/click/[id]/route.ts
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  const url = req.nextUrl.searchParams.get('url');
  
  if (!url) {
    return new NextResponse('URL required', { status: 400 });
  }
  
  // è®°å½•ç‚¹å‡»äº‹ä»¶
  await db.insert(emailEvents).values({
    emailId: params.id,
    event: 'clicked',
    url,
    userAgent: req.headers.get('user-agent'),
    ip: req.ip,
  });
  
  // é‡å®šå‘åˆ°åŸå§‹ URL
  return NextResponse.redirect(url);
}
```

### 3. é‚®ä»¶åˆ†æ

```typescript
// src/lib/mail/analytics.ts
export async function getEmailAnalytics(emailId: string) {
  const [sent, opened, clicked, bounced, complained] = await Promise.all([
    db.select({ count: count() })
      .from(emailLogs)
      .where(eq(emailLogs.id, emailId)),
    
    db.select({ count: count() })
      .from(emailEvents)
      .where(
        and(
          eq(emailEvents.emailId, emailId),
          eq(emailEvents.event, 'opened')
        )
      ),
    
    db.select({ count: count() })
      .from(emailEvents)
      .where(
        and(
          eq(emailEvents.emailId, emailId),
          eq(emailEvents.event, 'clicked')
        )
      ),
    
    db.select({ count: count() })
      .from(emailEvents)
      .where(
        and(
          eq(emailEvents.emailId, emailId),
          eq(emailEvents.event, 'bounced')
        )
      ),
    
    db.select({ count: count() })
      .from(emailEvents)
      .where(
        and(
          eq(emailEvents.emailId, emailId),
          eq(emailEvents.event, 'complained')
        )
      ),
  ]);
  
  return {
    sent: sent[0].count,
    opened: opened[0].count,
    clicked: clicked[0].count,
    bounced: bounced[0].count,
    complained: complained[0].count,
    openRate: (opened[0].count / sent[0].count) * 100,
    clickRate: (clicked[0].count / sent[0].count) * 100,
    bounceRate: (bounced[0].count / sent[0].count) * 100,
  };
}
```

## å…­ã€ç”¨æˆ·åå¥½ç®¡ç†

### 1. è®¢é˜…ç®¡ç†

```typescript
// src/lib/mail/preferences.ts
export interface EmailPreferences {
  userId: string;
  marketing: boolean;
  productUpdates: boolean;
  weeklyDigest: boolean;
  transactional: boolean; // å§‹ç»ˆä¸º true
}

export async function updateEmailPreferences(
  userId: string,
  preferences: Partial<EmailPreferences>
) {
  return db.update(emailPreferences)
    .set(preferences)
    .where(eq(emailPreferences.userId, userId));
}

export async function getEmailPreferences(userId: string) {
  return db.query.emailPreferences.findFirst({
    where: eq(emailPreferences.userId, userId),
  });
}

// æ£€æŸ¥æ˜¯å¦å¯ä»¥å‘é€é‚®ä»¶
export async function canSendEmail(
  userId: string,
  emailType: string
): Promise<boolean> {
  const prefs = await getEmailPreferences(userId);
  
  if (!prefs) {
    return true; // é»˜è®¤å…è®¸
  }
  
  // äº‹åŠ¡æ€§é‚®ä»¶å§‹ç»ˆå‘é€
  if (emailType === 'transactional') {
    return true;
  }
  
  return prefs[emailType] ?? true;
}
```

### 2. å–æ¶ˆè®¢é˜…

```typescript
// src/app/api/unsubscribe/route.ts
export async function GET(req: NextRequest) {
  const token = req.nextUrl.searchParams.get('token');
  
  if (!token) {
    return new NextResponse('Token required', { status: 400 });
  }
  
  // éªŒè¯ token
  const payload = await verifyToken(token);
  
  // æ›´æ–°åå¥½
  await db.update(emailPreferences)
    .set({ marketing: false })
    .where(eq(emailPreferences.userId, payload.userId));
  
  return NextResponse.redirect(
    `${process.env.NEXT_PUBLIC_APP_URL}/unsubscribed`
  );
}

// åœ¨é‚®ä»¶ä¸­æ·»åŠ å–æ¶ˆè®¢é˜…é“¾æ¥
export function addUnsubscribeLink(html: string, userId: string): string {
  const token = generateUnsubscribeToken(userId);
  const unsubscribeUrl = `${process.env.NEXT_PUBLIC_APP_URL}/api/unsubscribe?token=${token}`;
  
  const footer = `
    <p style="color: #8898aa; font-size: 12px;">
      ä¸æƒ³å†æ”¶åˆ°è¿™ç±»é‚®ä»¶ï¼Ÿ
      <a href="${unsubscribeUrl}" style="color: #5469d4;">å–æ¶ˆè®¢é˜…</a>
    </p>
  `;
  
  return html.replace('</body>', `${footer}</body>`);
}
```

## ä¸ƒã€é‚®ä»¶æµ‹è¯•

### 1. æœ¬åœ°æµ‹è¯•

```typescript
// src/lib/mail/test.ts
import { createTransport } from 'nodemailer';

// ä½¿ç”¨ Ethereal Email è¿›è¡Œæµ‹è¯•
export async function createTestEmailAccount() {
  const testAccount = await nodemailer.createTestAccount();
  
  const transporter = createTransport({
    host: 'smtp.ethereal.email',
    port: 587,
    secure: false,
    auth: {
      user: testAccount.user,
      pass: testAccount.pass,
    },
  });
  
  return { transporter, testAccount };
}

// å‘é€æµ‹è¯•é‚®ä»¶
export async function sendTestEmail() {
  const { transporter, testAccount } = await createTestEmailAccount();
  
  const info = await transporter.sendMail({
    from: '"MkSaaS" <noreply@mksaas.me>',
    to: 'test@example.com',
    subject: 'Test Email',
    html: '<p>This is a test email</p>',
  });
  
  console.log('Preview URL:', nodemailer.getTestMessageUrl(info));
}
```

### 2. é¢„è§ˆé‚®ä»¶

```typescript
// src/app/api/mail/preview/route.ts
export async function POST(req: NextRequest) {
  const { template, data } = await req.json();
  
  const html = renderTemplate(template, data);
  
  return NextResponse.json({ html });
}

// å‰ç«¯é¢„è§ˆç»„ä»¶
export function EmailPreview({ template, data }: EmailPreviewProps) {
  const [html, setHtml] = useState('');
  
  useEffect(() => {
    fetch('/api/mail/preview', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ template, data }),
    })
      .then(res => res.json())
      .then(({ html }) => setHtml(html));
  }, [template, data]);
  
  return (
    <iframe
      srcDoc={html}
      style={{ width: '100%', height: '600px', border: 'none' }}
    />
  );
}
```

## å…«ã€æœ€ä½³å®è·µ

### 1. å‘é€ç­–ç•¥

```typescript
// é€Ÿç‡é™åˆ¶
export const RATE_LIMITS = {
  transactional: 100, // æ¯åˆ†é’Ÿ100å°
  marketing: 10, // æ¯åˆ†é’Ÿ10å°
  bulk: 1000, // æ¯å°æ—¶1000å°
};

// é‡è¯•ç­–ç•¥
export const RETRY_CONFIG = {
  attempts: 3,
  backoff: {
    type: 'exponential',
    delay: 1000,
  },
};

// ä¼˜å…ˆçº§
export enum EmailPriority {
  HIGH = 'high', // äº‹åŠ¡æ€§é‚®ä»¶
  NORMAL = 'normal', // è¥é”€é‚®ä»¶
  LOW = 'low', // æ‰¹é‡é‚®ä»¶
}
```

### 2. å†…å®¹ä¼˜åŒ–

```typescript
// é‚®ä»¶å†…å®¹æ£€æŸ¥
export function validateEmailContent(email: Email): ValidationResult {
  const errors: string[] = [];
  
  // æ£€æŸ¥ä¸»é¢˜è¡Œ
  if (email.subject.length > 50) {
    errors.push('ä¸»é¢˜è¡Œè¿‡é•¿ï¼ˆå»ºè®®50å­—ç¬¦ä»¥å†…ï¼‰');
  }
  
  // æ£€æŸ¥å‘ä»¶äºº
  if (!email.from.includes('@')) {
    errors.push('æ— æ•ˆçš„å‘ä»¶äººåœ°å€');
  }
  
  // æ£€æŸ¥å†…å®¹
  if (!email.html && !email.text) {
    errors.push('é‚®ä»¶å†…å®¹ä¸èƒ½ä¸ºç©º');
  }
  
  // æ£€æŸ¥é“¾æ¥
  const links = extractLinks(email.html);
  if (links.some(link => !link.startsWith('https://'))) {
    errors.push('å»ºè®®ä½¿ç”¨ HTTPS é“¾æ¥');
  }
  
  return {
    valid: errors.length === 0,
    errors,
  };
}
```

### 3. æ€§èƒ½ä¼˜åŒ–

```typescript
// æ‰¹é‡å‘é€ä¼˜åŒ–
export async function sendBulkEmailsOptimized(emails: Email[]) {
  const BATCH_SIZE = 100;
  const batches = chunk(emails, BATCH_SIZE);
  
  for (const batch of batches) {
    await queueBulkEmails(batch);
    
    // é¿å…é€Ÿç‡é™åˆ¶
    await sleep(1000);
  }
}

// æ¨¡æ¿ç¼“å­˜
const templateCache = new Map<string, string>();

export function renderTemplateWithCache(
  templateId: string,
  data: any
): string {
  const cacheKey = `${templateId}:${JSON.stringify(data)}`;
  
  if (templateCache.has(cacheKey)) {
    return templateCache.get(cacheKey)!;
  }
  
  const html = renderTemplate(templateId, data);
  templateCache.set(cacheKey, html);
  
  return html;
}
```

## ä¹ã€ç›‘æ§ä¸å‘Šè­¦

### 1. é‚®ä»¶ç›‘æ§

```typescript
// src/lib/mail/monitoring.ts
export async function monitorEmailHealth() {
  const last24h = new Date(Date.now() - 24 * 60 * 60 * 1000);
  
  const stats = await db
    .select({
      total: count(),
      sent: count(emailLogs.status).where(eq(emailLogs.status, 'sent')),
      failed: count(emailLogs.status).where(eq(emailLogs.status, 'failed')),
      bounced: count(emailEvents.event).where(eq(emailEvents.event, 'bounced')),
    })
    .from(emailLogs)
    .where(gte(emailLogs.createdAt, last24h));
  
  const failureRate = (stats.failed / stats.total) * 100;
  const bounceRate = (stats.bounced / stats.total) * 100;
  
  // å‘Šè­¦é˜ˆå€¼
  if (failureRate > 5) {
    await sendAlert('é‚®ä»¶å‘é€å¤±è´¥ç‡è¿‡é«˜', { failureRate });
  }
  
  if (bounceRate > 2) {
    await sendAlert('é‚®ä»¶é€€ä¿¡ç‡è¿‡é«˜', { bounceRate });
  }
  
  return { stats, failureRate, bounceRate };
}
```

### 2. å‘Šè­¦é€šçŸ¥

```typescript
export async function sendAlert(message: string, data: any) {
  // å‘é€åˆ° Slack
  await fetch(process.env.SLACK_WEBHOOK_URL!, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      text: `ğŸš¨ é‚®ä»¶ç³»ç»Ÿå‘Šè­¦: ${message}`,
      attachments: [{
        color: 'danger',
        fields: Object.entries(data).map(([key, value]) => ({
          title: key,
          value: String(value),
          short: true,
        })),
      }],
    }),
  });
}
```

## æ€»ç»“

MkSaaS çš„é‚®ä»¶ç³»ç»Ÿæä¾›äº†å®Œæ•´çš„é‚®ä»¶å‘é€è§£å†³æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š

1. **å¤šç§é‚®ä»¶ç±»å‹**: äº‹åŠ¡æ€§ã€è¥é”€ã€è‡ªåŠ¨åŒ–é‚®ä»¶
2. **æ¨¡æ¿ç³»ç»Ÿ**: React Email æ¨¡æ¿ï¼Œæ˜“äºç»´æŠ¤
3. **é˜Ÿåˆ—å¤„ç†**: å¼‚æ­¥å‘é€ï¼Œæ”¯æŒå®šæ—¶å’Œé‡å¤
4. **è¿½è¸ªåˆ†æ**: æ‰“å¼€ç‡ã€ç‚¹å‡»ç‡ç­‰æŒ‡æ ‡
5. **ç”¨æˆ·åå¥½**: è®¢é˜…ç®¡ç†å’Œå–æ¶ˆè®¢é˜…
6. **æµ‹è¯•å·¥å…·**: æœ¬åœ°æµ‹è¯•å’Œé¢„è§ˆ
7. **ç›‘æ§å‘Šè­¦**: å®æ—¶ç›‘æ§é‚®ä»¶å¥åº·çŠ¶æ€

é€šè¿‡è¿™äº›åŠŸèƒ½ï¼Œå¯ä»¥æ„å»ºå¯é ã€é«˜æ•ˆçš„é‚®ä»¶é€šçŸ¥ç³»ç»Ÿã€‚
