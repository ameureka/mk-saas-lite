# 问题18：关于知识的管理的内容，如何管理处理的文档的上传以及模板的，内容综合的管理

## 概述

MkSaaS 提供了完整的知识管理和内容管理系统，包括基于 MDX 的文档管理、文件上传系统、版本控制和内容搜索索引。系统支持多种内容类型，并提供灵活的扩展能力。

## 一、内容管理架构

### 1. 内容类型系统

MkSaaS 使用 Fumadocs MDX 管理多种内容类型：

```
内容类型:
├── 文档 (Docs)
│   ├── 技术文档
│   ├── API 参考
│   └── 使用指南
├── 博客 (Blog)
│   ├── 文章
│   ├── 教程
│   └── 案例研究
├── 更新日志 (Changelog)
│   └── 版本更新记录
├── 页面 (Pages)
│   ├── 隐私政策
│   ├── 服务条款
│   └── 关于我们
├── 作者 (Authors)
│   └── 作者信息
└── 分类 (Categories)
    └── 内容分类
```

### 2. 内容配置

```typescript
// source.config.ts
import {
  defineCollections,
  defineDocs,
  frontmatterSchema,
  metaSchema,
} from 'fumadocs-mdx/config';
import { z } from 'zod';

/**
 * 文档配置
 */
export const docs = defineDocs({
  dir: 'content/docs',
  docs: {
    schema: frontmatterSchema.extend({
      preview: z.string().optional(),      // 预览文本
      index: z.boolean().default(false),   // 是否为索引页
      premium: z.boolean().optional(),     // 是否为付费内容
    }),
  },
  meta: {
    schema: metaSchema.extend({
      description: z.string().optional(),
    }),
  },
});

/**
 * 博客文章配置
 */
export const blog = defineCollections({
  type: 'doc',
  dir: 'content/blog',
  schema: frontmatterSchema.extend({
    image: z.string(),                     // 封面图片
    date: z.string().date(),               // 发布日期
    published: z.boolean().default(true), // 是否发布
    premium: z.boolean().optional(),       // 是否付费
    categories: z.array(z.string()),       // 分类
    author: z.string(),                    // 作者
  }),
});

/**
 * 更新日志配置
 */
export const changelog = defineCollections({
  type: 'doc',
  dir: 'content/changelog',
  schema: frontmatterSchema.extend({
    version: z.string(),                   // 版本号
    date: z.string().date(),               // 发布日期
    published: z.boolean().default(true), // 是否发布
  }),
});

/**
 * 静态页面配置
 */
export const pages = defineCollections({
  type: 'doc',
  dir: 'content/pages',
  schema: frontmatterSchema.extend({
    date: z.string().date(),
    published: z.boolean().default(true),
  }),
});

/**
 * 作者配置
 */
export const author = defineCollections({
  type: 'doc',
  dir: 'content/author',
  schema: z.object({
    name: z.string(),
    avatar: z.string(),
    description: z.string().optional(),
  }),
});

/**
 * 分类配置
 */
export const category = defineCollections({
  type: 'doc',
  dir: 'content/category',
  schema: z.object({
    name: z.string(),
    description: z.string().optional(),
  }),
});
```

## 二、MDX 内容管理

### 1. MDX 文件结构

#### 博客文章示例

```mdx
---
title: "如何使用 MkSaaS 构建 SaaS 应用"
description: "完整的 MkSaaS 使用指南，从零开始构建你的 SaaS 应用"
image: "/images/blog/mksaas-guide.jpg"
date: "2024-11-13"
published: true
premium: false
categories: ["教程", "技术"]
author: "fox"
---

# 如何使用 MkSaaS 构建 SaaS 应用

这是一篇关于如何使用 MkSaaS 的完整指南。

## 准备工作

首先，你需要...

## 安装步骤

```bash
git clone https://github.com/MkSaaSHQ/mksaas-template
cd mksaas-template
pnpm install
```

## 配置环境

创建 `.env.local` 文件...

<Callout type="info">
  这是一个提示框组件
</Callout>

## 总结

通过本教程，你学会了...
```

#### 文档示例

```mdx
---
title: "快速开始"
description: "5分钟快速上手 MkSaaS"
preview: "学习如何快速开始使用 MkSaaS"
index: false
premium: false
---

# 快速开始

欢迎使用 MkSaaS！

## 安装

\`\`\`bash
pnpm install
\`\`\`

## 配置

编辑 `src/config/website.tsx`...

## 运行

\`\`\`bash
pnpm dev
\`\`\`
```

### 2. 内容组件

#### 自定义 MDX 组件

```typescript
// src/components/docs/mdx-components.tsx
import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';
import { ImageZoom } from 'fumadocs-ui/components/image-zoom';
import { CodeBlock } from './code-block';
import { VideoEmbed } from './video-embed';

export const mdxComponents = {
  // 提示框
  Callout,
  
  // 标签页
  Tabs,
  Tab,
  
  // 手风琴
  Accordions,
  Accordion,
  
  // 图片缩放
  ImageZoom,
  
  // 代码块
  CodeBlock,
  
  // 视频嵌入
  VideoEmbed,
  
  // 自定义组件
  CustomComponent: ({ children }) => (
    <div className="custom-component">
      {children}
    </div>
  ),
};
```

#### 代码块组件

```typescript
// src/components/docs/code-block.tsx
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Check, Copy } from 'lucide-react';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';

interface CodeBlockProps {
  code: string;
  language: string;
  filename?: string;
  showLineNumbers?: boolean;
}

export function CodeBlock({
  code,
  language,
  filename,
  showLineNumbers = true,
}: CodeBlockProps) {
  const [copied, setCopied] = useState(false);
  
  const handleCopy = async () => {
    await navigator.clipboard.writeText(code);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };
  
  return (
    <div className="relative group">
      {filename && (
        <div className="px-4 py-2 bg-muted border-b">
          <span className="text-sm font-mono">{filename}</span>
        </div>
      )}
      
      <div className="relative">
        <Button
          size="sm"
          variant="ghost"
          className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity"
          onClick={handleCopy}
        >
          {copied ? (
            <Check className="h-4 w-4" />
          ) : (
            <Copy className="h-4 w-4" />
          )}
        </Button>
        
        <SyntaxHighlighter
          language={language}
          style={oneDark}
          showLineNumbers={showLineNumbers}
          customStyle={{
            margin: 0,
            borderRadius: filename ? '0 0 0.5rem 0.5rem' : '0.5rem',
          }}
        >
          {code}
        </SyntaxHighlighter>
      </div>
    </div>
  );
}
```

### 3. 内容查询

```typescript
// src/lib/content/queries.ts
import { blogSource, docsSource, categorySource } from '@/lib/source';
import type { Locale } from 'next-intl';

/**
 * 获取所有已发布的博客文章
 */
export function getPublishedPosts(locale: Locale) {
  return blogSource
    .getPages(locale)
    .filter(post => post.data.published)
    .sort((a, b) => 
      new Date(b.data.date).getTime() - new Date(a.data.date).getTime()
    );
}

/**
 * 获取分类下的文章
 */
export function getPostsByCategory(locale: Locale, categorySlug: string) {
  return blogSource
    .getPages(locale)
    .filter(post => 
      post.data.published &&
      post.data.categories.includes(categorySlug)
    )
    .sort((a, b) => 
      new Date(b.data.date).getTime() - new Date(a.data.date).getTime()
    );
}

/**
 * 获取相关文章
 */
export function getRelatedPosts(
  locale: Locale,
  currentPostSlug: string,
  limit: number = 3
) {
  const currentPost = blogSource
    .getPages(locale)
    .find(post => post.slugs.join('/') === currentPostSlug);
  
  if (!currentPost) return [];
  
  const currentCategories = currentPost.data.categories;
  
  return blogSource
    .getPages(locale)
    .filter(post => 
      post.data.published &&
      post.slugs.join('/') !== currentPostSlug &&
      post.data.categories.some(cat => currentCategories.includes(cat))
    )
    .sort((a, b) => {
      // 按共同分类数量排序
      const aCommon = a.data.categories.filter(cat => 
        currentCategories.includes(cat)
      ).length;
      const bCommon = b.data.categories.filter(cat => 
        currentCategories.includes(cat)
      ).length;
      return bCommon - aCommon;
    })
    .slice(0, limit);
}

/**
 * 搜索内容
 */
export function searchContent(locale: Locale, query: string) {
  const lowerQuery = query.toLowerCase();
  
  const posts = blogSource
    .getPages(locale)
    .filter(post => 
      post.data.published &&
      (post.data.title.toLowerCase().includes(lowerQuery) ||
       post.data.description?.toLowerCase().includes(lowerQuery))
    );
  
  const docs = docsSource
    .getPages(locale)
    .filter(doc => 
      doc.data.title.toLowerCase().includes(lowerQuery) ||
      doc.data.description?.toLowerCase().includes(lowerQuery)
    );
  
  return {
    posts,
    docs,
    total: posts.length + docs.length,
  };
}
```

## 三、文件上传系统

### 1. 存储配置

```typescript
// src/storage/config/storage-config.ts
import { StorageConfig } from '../types';

export const storageConfig: StorageConfig = {
  region: process.env.STORAGE_REGION || 'auto',
  endpoint: process.env.STORAGE_ENDPOINT,
  accessKeyId: process.env.STORAGE_ACCESS_KEY_ID!,
  secretAccessKey: process.env.STORAGE_SECRET_ACCESS_KEY!,
  bucketName: process.env.STORAGE_BUCKET_NAME!,
  publicUrl: process.env.STORAGE_PUBLIC_URL,
  forcePathStyle: true,
};
```

### 2. 服务端上传

```typescript
// src/lib/upload/server-upload.ts
import { uploadFile } from '@/storage';
import { nanoid } from 'nanoid';
import path from 'path';

/**
 * 上传文件到存储
 */
export async function uploadFileToStorage(
  file: Buffer | Blob,
  originalFilename: string,
  folder: string = 'uploads'
): Promise<{
  url: string;
  key: string;
  filename: string;
}> {
  // 生成唯一文件名
  const ext = path.extname(originalFilename);
  const basename = path.basename(originalFilename, ext);
  const uniqueFilename = `${basename}-${nanoid()}${ext}`;
  
  // 检测文件类型
  const contentType = getContentType(ext);
  
  // 上传文件
  const result = await uploadFile(
    file,
    uniqueFilename,
    contentType,
    folder
  );
  
  return {
    ...result,
    filename: uniqueFilename,
  };
}

/**
 * 根据扩展名获取 Content-Type
 */
function getContentType(ext: string): string {
  const contentTypes: Record<string, string> = {
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.png': 'image/png',
    '.gif': 'image/gif',
    '.webp': 'image/webp',
    '.svg': 'image/svg+xml',
    '.pdf': 'application/pdf',
    '.doc': 'application/msword',
    '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    '.xls': 'application/vnd.ms-excel',
    '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    '.zip': 'application/zip',
    '.mp4': 'video/mp4',
    '.mp3': 'audio/mpeg',
  };
  
  return contentTypes[ext.toLowerCase()] || 'application/octet-stream';
}

/**
 * 验证文件
 */
export function validateFile(
  file: File,
  options: {
    maxSize?: number;
    allowedTypes?: string[];
  } = {}
): { valid: boolean; error?: string } {
  const {
    maxSize = 10 * 1024 * 1024, // 10MB
    allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
  } = options;
  
  // 检查文件大小
  if (file.size > maxSize) {
    return {
      valid: false,
      error: `File size exceeds ${maxSize / 1024 / 1024}MB`,
    };
  }
  
  // 检查文件类型
  if (!allowedTypes.includes(file.type)) {
    return {
      valid: false,
      error: `File type ${file.type} is not allowed`,
    };
  }
  
  return { valid: true };
}
```

### 3. API 路由

```typescript
// src/app/api/upload/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { requireAuth } from '@/lib/api-middleware';
import { uploadFileToStorage, validateFile } from '@/lib/upload/server-upload';

export async function POST(req: NextRequest) {
  // 验证用户
  const session = await requireAuth(req);
  
  if (session instanceof NextResponse) {
    return session;
  }
  
  try {
    const formData = await req.formData();
    const file = formData.get('file') as File;
    const folder = formData.get('folder') as string || 'uploads';
    
    if (!file) {
      return NextResponse.json(
        { error: 'No file provided' },
        { status: 400 }
      );
    }
    
    // 验证文件
    const validation = validateFile(file, {
      maxSize: 10 * 1024 * 1024, // 10MB
      allowedTypes: [
        'image/jpeg',
        'image/png',
        'image/gif',
        'image/webp',
        'application/pdf',
      ],
    });
    
    if (!validation.valid) {
      return NextResponse.json(
        { error: validation.error },
        { status: 400 }
      );
    }
    
    // 转换为 Buffer
    const buffer = Buffer.from(await file.arrayBuffer());
    
    // 上传文件
    const result = await uploadFileToStorage(
      buffer,
      file.name,
      folder
    );
    
    return NextResponse.json({
      success: true,
      data: result,
    });
    
  } catch (error) {
    console.error('Upload error:', error);
    return NextResponse.json(
      { error: 'Upload failed' },
      { status: 500 }
    );
  }
}

// 配置
export const config = {
  api: {
    bodyParser: false,
  },
};
```

### 4. 客户端上传组件

```typescript
// src/components/upload/file-uploader.tsx
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { Upload, X, Check } from 'lucide-react';
import { uploadFileFromBrowser } from '@/storage/client';

interface FileUploaderProps {
  folder?: string;
  accept?: string;
  maxSize?: number;
  onUploadComplete?: (result: { url: string; key: string }) => void;
}

export function FileUploader({
  folder = 'uploads',
  accept = 'image/*',
  maxSize = 10 * 1024 * 1024,
  onUploadComplete,
}: FileUploaderProps) {
  const [file, setFile] = useState<File | null>(null);
  const [uploading, setUploading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [result, setResult] = useState<{ url: string; key: string } | null>(null);
  const [error, setError] = useState<string | null>(null);
  
  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = e.target.files?.[0];
    
    if (!selectedFile) return;
    
    // 验证文件大小
    if (selectedFile.size > maxSize) {
      setError(`File size exceeds ${maxSize / 1024 / 1024}MB`);
      return;
    }
    
    setFile(selectedFile);
    setError(null);
    setResult(null);
  };
  
  const handleUpload = async () => {
    if (!file) return;
    
    setUploading(true);
    setProgress(0);
    setError(null);
    
    try {
      // 模拟进度
      const progressInterval = setInterval(() => {
        setProgress(prev => Math.min(prev + 10, 90));
      }, 200);
      
      // 上传文件
      const uploadResult = await uploadFileFromBrowser(file, folder);
      
      clearInterval(progressInterval);
      setProgress(100);
      
      setResult(uploadResult);
      
      if (onUploadComplete) {
        onUploadComplete(uploadResult);
      }
      
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Upload failed');
    } finally {
      setUploading(false);
    }
  };
  
  const handleClear = () => {
    setFile(null);
    setResult(null);
    setError(null);
    setProgress(0);
  };
  
  return (
    <div className="space-y-4">
      {/* 文件选择 */}
      {!file && !result && (
        <div className="border-2 border-dashed rounded-lg p-8 text-center">
          <Upload className="mx-auto h-12 w-12 text-muted-foreground" />
          <p className="mt-2 text-sm text-muted-foreground">
            Click to upload or drag and drop
          </p>
          <p className="text-xs text-muted-foreground">
            Max size: {maxSize / 1024 / 1024}MB
          </p>
          <input
            type="file"
            accept={accept}
            onChange={handleFileSelect}
            className="mt-4"
          />
        </div>
      )}
      
      {/* 文件预览 */}
      {file && !result && (
        <div className="space-y-4">
          <div className="flex items-center justify-between p-4 border rounded-lg">
            <div className="flex items-center gap-2">
              <Upload className="h-4 w-4" />
              <span className="text-sm">{file.name}</span>
              <span className="text-xs text-muted-foreground">
                ({(file.size / 1024).toFixed(2)} KB)
              </span>
            </div>
            <Button
              size="sm"
              variant="ghost"
              onClick={handleClear}
            >
              <X className="h-4 w-4" />
            </Button>
          </div>
          
          {uploading && (
            <Progress value={progress} />
          )}
          
          <Button
            onClick={handleUpload}
            disabled={uploading}
            className="w-full"
          >
            {uploading ? 'Uploading...' : 'Upload'}
          </Button>
        </div>
      )}
      
      {/* 上传成功 */}
      {result && (
        <div className="space-y-4">
          <div className="flex items-center gap-2 p-4 border rounded-lg bg-green-50 dark:bg-green-950">
            <Check className="h-4 w-4 text-green-600" />
            <span className="text-sm">Upload successful!</span>
          </div>
          
          <div className="p-4 border rounded-lg">
            <p className="text-sm font-medium mb-2">File URL:</p>
            <code className="text-xs break-all">{result.url}</code>
          </div>
          
          <Button
            onClick={handleClear}
            variant="outline"
            className="w-full"
          >
            Upload Another File
          </Button>
        </div>
      )}
      
      {/* 错误提示 */}
      {error && (
        <div className="p-4 border border-red-200 rounded-lg bg-red-50 dark:bg-red-950">
          <p className="text-sm text-red-600">{error}</p>
        </div>
      )}
    </div>
  );
}
```

## 四、版本控制

### 1. Git 版本管理

内容文件使用 Git 进行版本控制：

```bash
# 添加新内容
git add content/blog/new-post.mdx
git commit -m "Add: new blog post about..."

# 更新内容
git add content/blog/existing-post.mdx
git commit -m "Update: improve blog post content"

# 删除内容
git rm content/blog/old-post.mdx
git commit -m "Remove: outdated blog post"
```

### 2. 内容审核工作流

```typescript
// src/lib/content/workflow.ts
export enum ContentStatus {
  DRAFT = 'draft',
  REVIEW = 'review',
  PUBLISHED = 'published',
  ARCHIVED = 'archived',
}

export interface ContentMetadata {
  status: ContentStatus;
  author: string;
  reviewer?: string;
  publishedAt?: Date;
  updatedAt: Date;
  version: number;
}

/**
 * 内容工作流管理
 */
export class ContentWorkflow {
  /**
   * 提交审核
   */
  static async submitForReview(
    contentId: string,
    author: string
  ): Promise<void> {
    // 更新内容状态
    await updateContentStatus(contentId, {
      status: ContentStatus.REVIEW,
      author,
      updatedAt: new Date(),
    });
    
    // 通知审核人员
    await notifyReviewers(contentId);
  }
  
  /**
   * 批准发布
   */
  static async approve(
    contentId: string,
    reviewer: string
  ): Promise<void> {
    await updateContentStatus(contentId, {
      status: ContentStatus.PUBLISHED,
      reviewer,
      publishedAt: new Date(),
      updatedAt: new Date(),
    });
    
    // 通知作者
    await notifyAuthor(contentId, 'approved');
  }
  
  /**
   * 拒绝发布
   */
  static async reject(
    contentId: string,
    reviewer: string,
    reason: string
  ): Promise<void> {
    await updateContentStatus(contentId, {
      status: ContentStatus.DRAFT,
      reviewer,
      updatedAt: new Date(),
    });
    
    // 通知作者
    await notifyAuthor(contentId, 'rejected', reason);
  }
}
```

## 五、内容搜索索引

### 1. 全文搜索索引

```typescript
// src/lib/search/content-indexer.ts
import { create, insert } from '@orama/orama';
import { blogSource, docsSource } from '@/lib/source';
import type { Locale } from 'next-intl';

/**
 * 创建内容搜索索引
 */
export async function createContentIndex(locale: Locale) {
  const db = await create({
    schema: {
      id: 'string',
      type: 'string',        // 'blog' | 'docs'
      title: 'string',
      description: 'string',
      content: 'string',
      url: 'string',
      categories: 'string[]',
      author: 'string',
      date: 'string',
    },
  });
  
  // 索引博客文章
  const posts = blogSource
    .getPages(locale)
    .filter(post => post.data.published);
  
  for (const post of posts) {
    await insert(db, {
      id: post.slugs.join('/'),
      type: 'blog',
      title: post.data.title,
      description: post.data.description || '',
      content: post.content,
      url: `/blog/${post.slugs.join('/')}`,
      categories: post.data.categories,
      author: post.data.author,
      date: post.data.date,
    });
  }
  
  // 索引文档
  const docs = docsSource.getPages(locale);
  
  for (const doc of docs) {
    await insert(db, {
      id: doc.slugs.join('/'),
      type: 'docs',
      title: doc.data.title,
      description: doc.data.description || '',
      content: doc.content,
      url: `/docs/${doc.slugs.join('/')}`,
      categories: [],
      author: '',
      date: '',
    });
  }
  
  return db;
}
```

### 2. 向量搜索索引

```typescript
// src/lib/search/vector-indexer.ts
import { generateEmbedding } from '@/lib/ai/embeddings';
import { upsertVectors } from '@/lib/vector/pinecone';
import { blogSource } from '@/lib/source';
import type { Locale } from 'next-intl';

/**
 * 为内容生成向量索引
 */
export async function indexContentVectors(locale: Locale) {
  const posts = blogSource
    .getPages(locale)
    .filter(post => post.data.published);
  
  const documents = posts.map(post => ({
    id: `blog-${post.slugs.join('-')}`,
    text: `${post.data.title}\n\n${post.data.description}\n\n${post.content}`,
    metadata: {
      type: 'blog',
      title: post.data.title,
      url: `/blog/${post.slugs.join('/')}`,
      categories: post.data.categories,
      date: post.data.date,
    },
  }));
  
  // 批量上传向量
  await upsertVectors(documents);
}
```

## 六、内容导入导出

### 1. 批量导入

```typescript
// scripts/import-content.ts
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

interface ImportOptions {
  sourceDir: string;
  targetDir: string;
  contentType: 'blog' | 'docs';
}

/**
 * 批量导入内容
 */
async function importContent(options: ImportOptions) {
  const { sourceDir, targetDir, contentType } = options;
  
  // 读取源目录
  const files = fs.readdirSync(sourceDir);
  
  for (const file of files) {
    if (!file.endsWith('.md') && !file.endsWith('.mdx')) {
      continue;
    }
    
    const sourcePath = path.join(sourceDir, file);
    const content = fs.readFileSync(sourcePath, 'utf-8');
    
    // 解析 frontmatter
    const { data, content: body } = matter(content);
    
    // 转换格式
    const converted = convertToMkSaaSFormat(data, body, contentType);
    
    // 写入目标目录
    const targetPath = path.join(targetDir, file);
    fs.writeFileSync(targetPath, converted);
    
    console.log(`Imported: ${file}`);
  }
}

/**
 * 转换为 MkSaaS 格式
 */
function convertToMkSaaSFormat(
  frontmatter: any,
  content: string,
  type: 'blog' | 'docs'
): string {
  const converted = {
    title: frontmatter.title,
    description: frontmatter.description || '',
    ...(type === 'blog' && {
      image: frontmatter.image || '/images/default.jpg',
      date: frontmatter.date || new Date().toISOString().split('T')[0],
      published: frontmatter.published !== false,
      categories: frontmatter.categories || [],
      author: frontmatter.author || 'default',
    }),
  };
  
  return `---\n${JSON.stringify(converted, null, 2)}\n---\n\n${content}`;
}

// 运行导入
importContent({
  sourceDir: './import/blog',
  targetDir: './content/blog',
  contentType: 'blog',
});
```

### 2. 批量导出

```typescript
// scripts/export-content.ts
import fs from 'fs';
import path from 'path';
import { blogSource } from '../src/lib/source';

/**
 * 导出内容为 JSON
 */
async function exportContent(outputPath: string) {
  const posts = blogSource.getPages('en');
  
  const exported = posts.map(post => ({
    slug: post.slugs.join('/'),
    title: post.data.title,
    description: post.data.description,
    content: post.content,
    metadata: {
      date: post.data.date,
      author: post.data.author,
      categories: post.data.categories,
      published: post.data.published,
    },
  }));
  
  fs.writeFileSync(
    outputPath,
    JSON.stringify(exported, null, 2)
  );
  
  console.log(`Exported ${exported.length} posts to ${outputPath}`);
}

// 运行导出
exportContent('./export/blog-content.json');
```

## 七、内容备份

### 1. 自动备份脚本

```typescript
// scripts/backup-content.ts
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

/**
 * 备份内容目录
 */
async function backupContent() {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const backupDir = `./backups/content-${timestamp}`;
  
  // 创建备份目录
  fs.mkdirSync(backupDir, { recursive: true });
  
  // 复制内容目录
  execSync(`cp -r ./content ${backupDir}/`);
  
  // 创建压缩包
  execSync(`tar -czf ${backupDir}.tar.gz ${backupDir}`);
  
  // 删除临时目录
  execSync(`rm -rf ${backupDir}`);
  
  console.log(`Backup created: ${backupDir}.tar.gz`);
  
  // 清理旧备份（保留最近10个）
  cleanOldBackups('./backups', 10);
}

/**
 * 清理旧备份
 */
function cleanOldBackups(backupDir: string, keep: number) {
  const files = fs.readdirSync(backupDir)
    .filter(f => f.endsWith('.tar.gz'))
    .map(f => ({
      name: f,
      path: path.join(backupDir, f),
      time: fs.statSync(path.join(backupDir, f)).mtime.getTime(),
    }))
    .sort((a, b) => b.time - a.time);
  
  // 删除超出保留数量的备份
  files.slice(keep).forEach(file => {
    fs.unlinkSync(file.path);
    console.log(`Deleted old backup: ${file.name}`);
  });
}

// 运行备份
backupContent();
```

### 2. 定时备份

```yaml
# .github/workflows/backup-content.yml
name: Backup Content

on:
  schedule:
    # 每天凌晨 2 点备份
    - cron: '0 2 * * *'
  workflow_dispatch:

jobs:
  backup:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Create backup
        run: |
          timestamp=$(date +%Y%m%d-%H%M%S)
          tar -czf content-backup-$timestamp.tar.gz content/
      
      - name: Upload to S3
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          aws s3 cp content-backup-*.tar.gz s3://your-bucket/backups/
```

## 八、最佳实践

### 1. 内容组织

- 使用清晰的目录结构
- 统一的命名规范
- 合理的分类体系
- 完整的元数据

### 2. 文件管理

- 图片优化后上传
- 使用 CDN 加速
- 定期清理未使用文件
- 实施访问控制

### 3. 版本控制

- 有意义的提交信息
- 定期备份
- 使用分支管理
- 代码审查

### 4. 性能优化

- 图片懒加载
- 代码分割
- 缓存策略
- CDN 分发

## 总结

MkSaaS 提供了完整的知识管理和内容管理系统：

1. **MDX 内容管理**: 灵活的内容类型系统
2. **文件上传**: 完整的上传和存储方案
3. **版本控制**: Git 集成和工作流
4. **搜索索引**: 全文和向量搜索
5. **导入导出**: 批量内容迁移
6. **自动备份**: 定期备份和恢复
7. **最佳实践**: 完善的管理规范

通过这些功能，可以高效地管理和组织各类知识内容。
