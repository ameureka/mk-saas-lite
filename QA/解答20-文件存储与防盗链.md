# 问题20：文件下载使用 COS 以及防盗链、邮件发送处理

## 概述

MkSaaS 提供完整的文件存储和邮件发送解决方案，支持多种云存储服务（S3、R2、COS）和邮件服务提供商（Resend、Postmark）。本文详细介绍文件存储、防盗链机制和邮件发送的实现。

## 一、文件存储架构

### 1. 存储提供商抽象层

```typescript
// src/storage/provider/base.ts
export interface StorageProvider {
  // 上传文件
  upload(file: File, options?: UploadOptions): Promise<UploadResult>;
  
  // 生成签名 URL
  getSignedUrl(key: string, expiresIn?: number): Promise<string>;
  
  // 删除文件
  delete(key: string): Promise<void>;
  
  // 获取文件信息
  getMetadata(key: string): Promise<FileMetadata>;
  
  // 列出文件
  list(prefix?: string): Promise<FileInfo[]>;
}

export interface UploadOptions {
  bucket?: string;
  key?: string;
  contentType?: string;
  metadata?: Record<string, string>;
  acl?: 'private' | 'public-read';
}

export interface UploadResult {
  key: string;
  url: string;
  bucket: string;
  etag?: string;
  size: number;
}
```

### 2. S3 兼容存储实现

```typescript
// src/storage/provider/s3.ts
import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

export class S3StorageProvider implements StorageProvider {
  private client: S3Client;
  private bucket: string;
  
  constructor(config: S3Config) {
    this.client = new S3Client({
      region: config.region,
      credentials: {
        accessKeyId: config.accessKeyId,
        secretAccessKey: config.secretAccessKey,
      },
      endpoint: config.endpoint, // 支持自定义端点（如 COS、R2）
    });
    this.bucket = config.bucket;
  }
  
  async upload(file: File, options?: UploadOptions): Promise<UploadResult> {
    const key = options?.key || this.generateKey(file.name);
    const buffer = Buffer.from(await file.arrayBuffer());
    
    const command = new PutObjectCommand({
      Bucket: options?.bucket || this.bucket,
      Key: key,
      Body: buffer,
      ContentType: options?.contentType || file.type,
      Metadata: options?.metadata,
      ACL: options?.acl || 'private',
    });

    
    const result = await this.client.send(command);
    
    return {
      key,
      url: this.getPublicUrl(key),
      bucket: options?.bucket || this.bucket,
      etag: result.ETag,
      size: buffer.length,
    };
  }
  
  async getSignedUrl(key: string, expiresIn = 3600): Promise<string> {
    const command = new GetObjectCommand({
      Bucket: this.bucket,
      Key: key,
    });
    
    return getSignedUrl(this.client, command, { expiresIn });
  }
  
  async delete(key: string): Promise<void> {
    const command = new DeleteObjectCommand({
      Bucket: this.bucket,
      Key: key,
    });
    
    await this.client.send(command);
  }
  
  private generateKey(filename: string): string {
    const ext = filename.split('.').pop();
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(7);
    return `uploads/${timestamp}-${random}.${ext}`;
  }
  
  private getPublicUrl(key: string): string {
    return `https://${this.bucket}.s3.amazonaws.com/${key}`;
  }
}
```

### 3. 腾讯云 COS 配置

```typescript
// src/storage/provider/cos.ts
import { S3StorageProvider } from './s3';

export class COSStorageProvider extends S3StorageProvider {
  constructor(config: COSConfig) {
    super({
      region: config.region,
      accessKeyId: config.secretId,
      secretAccessKey: config.secretKey,
      bucket: config.bucket,
      endpoint: `https://cos.${config.region}.myqcloud.com`,
    });
  }
  
  protected getPublicUrl(key: string): string {
    return `https://${this.bucket}.cos.${this.region}.myqcloud.com/${key}`;
  }
}

// 配置示例
const cosProvider = new COSStorageProvider({
  region: 'ap-guangzhou',
  secretId: process.env.COS_SECRET_ID!,
  secretKey: process.env.COS_SECRET_KEY!,
  bucket: 'mksaas-1234567890',
});
```

## 二、防盗链机制

### 1. 签名 URL 防盗链

```typescript
// src/lib/storage/anti-hotlink.ts
import { createHmac } from 'crypto';

export class AntiHotlinkService {
  private secret: string;
  
  constructor(secret: string) {
    this.secret = secret;
  }
  
  // 生成带签名的 URL
  generateSecureUrl(
    baseUrl: string,
    expiresIn: number = 3600
  ): string {
    const expires = Math.floor(Date.now() / 1000) + expiresIn;
    const path = new URL(baseUrl).pathname;
    
    // 生成签名
    const signature = this.generateSignature(path, expires);
    
    // 添加签名参数
    const url = new URL(baseUrl);
    url.searchParams.set('expires', expires.toString());
    url.searchParams.set('signature', signature);
    
    return url.toString();
  }
  
  // 验证签名
  verifySignature(
    path: string,
    expires: number,
    signature: string
  ): boolean {
    // 检查是否过期
    if (Date.now() / 1000 > expires) {
      return false;
    }
    
    // 验证签名
    const expectedSignature = this.generateSignature(path, expires);
    return signature === expectedSignature;
  }
  
  private generateSignature(path: string, expires: number): string {
    const data = `${path}:${expires}`;
    return createHmac('sha256', this.secret)
      .update(data)
      .digest('hex');
  }
}
```

### 2. Referer 防盗链

```typescript
// src/middleware/anti-hotlink.ts
import { NextRequest, NextResponse } from 'next/server';

export function antiHotlinkMiddleware(req: NextRequest) {
  const referer = req.headers.get('referer');
  const allowedDomains = [
    'mksaas.me',
    'localhost:3000',
  ];
  
  // 检查 Referer
  if (referer) {
    const refererDomain = new URL(referer).hostname;
    const isAllowed = allowedDomains.some(domain => 
      refererDomain === domain || refererDomain.endsWith(`.${domain}`)
    );
    
    if (!isAllowed) {
      return new NextResponse('Forbidden', { status: 403 });
    }
  }
  
  return NextResponse.next();
}
```

### 3. Token 验证防盗链

```typescript
// src/app/api/files/[key]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { verifyToken } from '@/lib/auth';
import { storageService } from '@/lib/storage';

export async function GET(
  req: NextRequest,
  { params }: { params: { key: string } }
) {
  const token = req.nextUrl.searchParams.get('token');
  const expires = req.nextUrl.searchParams.get('expires');
  const signature = req.nextUrl.searchParams.get('signature');
  
  // 方式1: JWT Token 验证
  if (token) {
    try {
      const payload = await verifyToken(token);
      if (payload.fileKey !== params.key) {
        return new NextResponse('Invalid token', { status: 403 });
      }
    } catch (error) {
      return new NextResponse('Invalid token', { status: 403 });
    }
  }
  
  // 方式2: 签名验证
  else if (expires && signature) {
    const antiHotlink = new AntiHotlinkService(process.env.HOTLINK_SECRET!);
    const isValid = antiHotlink.verifySignature(
      `/api/files/${params.key}`,
      parseInt(expires),
      signature
    );
    
    if (!isValid) {
      return new NextResponse('Invalid signature', { status: 403 });
    }
  }
  
  // 无有效验证
  else {
    return new NextResponse('Unauthorized', { status: 401 });
  }
  
  // 获取文件
  const signedUrl = await storageService.getSignedUrl(params.key);
  
  // 重定向到签名 URL
  return NextResponse.redirect(signedUrl);
}
```

### 4. CDN 防盗链配置

```typescript
// Cloudflare Workers 防盗链
export default {
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);
    const referer = request.headers.get('Referer');
    
    // 允许的域名
    const allowedDomains = ['mksaas.me', 'localhost'];
    
    // 检查 Referer
    if (referer) {
      const refererUrl = new URL(referer);
      const isAllowed = allowedDomains.some(domain =>
        refererUrl.hostname.includes(domain)
      );
      
      if (!isAllowed) {
        return new Response('Forbidden', { status: 403 });
      }
    }
    
    // 转发请求
    return fetch(request);
  },
};
```

## 三、文件下载实现

### 1. 安全下载 API

```typescript
// src/app/api/download/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { db } from '@/db';
import { files } from '@/db/schema';
import { eq } from 'drizzle-orm';
import { storageService } from '@/lib/storage';

export async function GET(req: NextRequest) {
  const session = await auth();
  const fileId = req.nextUrl.searchParams.get('id');
  
  if (!fileId) {
    return new NextResponse('File ID required', { status: 400 });
  }
  
  // 查询文件信息
  const file = await db.query.files.findFirst({
    where: eq(files.id, fileId),
  });
  
  if (!file) {
    return new NextResponse('File not found', { status: 404 });
  }
  
  // 权限检查
  if (file.isPrivate && file.userId !== session?.user?.id) {
    return new NextResponse('Unauthorized', { status: 403 });
  }
  
  // 记录下载
  await db.insert(downloads).values({
    fileId,
    userId: session?.user?.id,
    ip: req.ip,
    userAgent: req.headers.get('user-agent'),
  });
  
  // 生成签名 URL
  const signedUrl = await storageService.getSignedUrl(
    file.key,
    3600 // 1小时有效期
  );
  
  // 重定向到签名 URL
  return NextResponse.redirect(signedUrl);
}
```

### 2. 前端下载组件

```typescript
// src/components/file-download.tsx
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Download, Loader2 } from 'lucide-react';

interface FileDownloadProps {
  fileId: string;
  fileName: string;
}

export function FileDownload({ fileId, fileName }: FileDownloadProps) {
  const [isDownloading, setIsDownloading] = useState(false);
  
  const handleDownload = async () => {
    setIsDownloading(true);
    
    try {
      // 获取下载 URL
      const response = await fetch(`/api/download?id=${fileId}`);
      
      if (!response.ok) {
        throw new Error('Download failed');
      }
      
      // 获取签名 URL
      const { url } = await response.json();
      
      // 触发下载
      const link = document.createElement('a');
      link.href = url;
      link.download = fileName;
      link.click();
    } catch (error) {
      console.error('Download error:', error);
      alert('下载失败，请重试');
    } finally {
      setIsDownloading(false);
    }
  };
  
  return (
    <Button
      onClick={handleDownload}
      disabled={isDownloading}
    >
      {isDownloading ? (
        <>
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          下载中...
        </>
      ) : (
        <>
          <Download className="mr-2 h-4 w-4" />
          下载文件
        </>
      )}
    </Button>
  );
}
```

### 3. 下载统计

```typescript
// src/db/schema.ts
export const downloads = pgTable('downloads', {
  id: text('id').primaryKey().$defaultFn(() => nanoid()),
  fileId: text('file_id').notNull().references(() => files.id),
  userId: text('user_id').references(() => users.id),
  ip: text('ip'),
  userAgent: text('user_agent'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
});

// 查询下载统计
export async function getDownloadStats(fileId: string) {
  const stats = await db
    .select({
      total: count(),
      unique: countDistinct(downloads.userId),
    })
    .from(downloads)
    .where(eq(downloads.fileId, fileId));
  
  return stats[0];
}
```

## 四、邮件发送系统

### 1. 邮件提供商抽象层

```typescript
// src/mail/provider/base.ts
export interface EmailProvider {
  send(email: Email): Promise<EmailResult>;
  sendBatch(emails: Email[]): Promise<EmailResult[]>;
}

export interface Email {
  from: string;
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  attachments?: Attachment[];
  replyTo?: string;
  cc?: string[];
  bcc?: string[];
}

export interface EmailResult {
  id: string;
  success: boolean;
  error?: string;
}
```


### 2. Resend 邮件服务

```typescript
// src/mail/provider/resend.ts
import { Resend } from 'resend';

export class ResendEmailProvider implements EmailProvider {
  private client: Resend;
  
  constructor(apiKey: string) {
    this.client = new Resend(apiKey);
  }
  
  async send(email: Email): Promise<EmailResult> {
    try {
      const result = await this.client.emails.send({
        from: email.from,
        to: email.to,
        subject: email.subject,
        html: email.html,
        text: email.text,
        reply_to: email.replyTo,
        cc: email.cc,
        bcc: email.bcc,
        attachments: email.attachments,
      });
      
      return {
        id: result.data?.id || '',
        success: true,
      };
    } catch (error) {
      return {
        id: '',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }
  
  async sendBatch(emails: Email[]): Promise<EmailResult[]> {
    return Promise.all(emails.map(email => this.send(email)));
  }
}
```

### 3. 邮件模板系统

```typescript
// src/mail/templates/welcome.tsx
import { Html, Head, Body, Container, Text, Button } from '@react-email/components';

interface WelcomeEmailProps {
  name: string;
  verifyUrl: string;
}

export function WelcomeEmail({ name, verifyUrl }: WelcomeEmailProps) {
  return (
    <Html>
      <Head />
      <Body style={main}>
        <Container style={container}>
          <Text style={heading}>欢迎加入 MkSaaS！</Text>
          <Text style={paragraph}>
            你好 {name}，
          </Text>
          <Text style={paragraph}>
            感谢你注册 MkSaaS。请点击下面的按钮验证你的邮箱地址：
          </Text>
          <Button style={button} href={verifyUrl}>
            验证邮箱
          </Button>
          <Text style={paragraph}>
            如果你没有注册 MkSaaS，请忽略此邮件。
          </Text>
        </Container>
      </Body>
    </Html>
  );
}

const main = {
  backgroundColor: '#f6f9fc',
  fontFamily: '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Ubuntu,sans-serif',
};

const container = {
  backgroundColor: '#ffffff',
  margin: '0 auto',
  padding: '20px 0 48px',
  marginBottom: '64px',
};

const heading = {
  fontSize: '32px',
  lineHeight: '1.3',
  fontWeight: '700',
  color: '#484848',
};

const paragraph = {
  fontSize: '18px',
  lineHeight: '1.4',
  color: '#484848',
};

const button = {
  backgroundColor: '#5469d4',
  borderRadius: '5px',
  color: '#fff',
  fontSize: '16px',
  fontWeight: 'bold',
  textDecoration: 'none',
  textAlign: 'center' as const,
  display: 'block',
  width: '100%',
  padding: '10px',
};
```

### 4. 邮件发送服务

```typescript
// src/lib/mail.ts
import { render } from '@react-email/render';
import { ResendEmailProvider } from '@/mail/provider/resend';
import { WelcomeEmail } from '@/mail/templates/welcome';
import { db } from '@/db';
import { emailLogs } from '@/db/schema';

const emailProvider = new ResendEmailProvider(process.env.RESEND_API_KEY!);

export const mailService = {
  // 发送欢迎邮件
  async sendWelcomeEmail(to: string, name: string, verifyUrl: string) {
    const html = render(WelcomeEmail({ name, verifyUrl }));
    
    const result = await emailProvider.send({
      from: 'MkSaaS <noreply@mksaas.me>',
      to,
      subject: '欢迎加入 MkSaaS',
      html,
    });
    
    // 记录邮件日志
    await db.insert(emailLogs).values({
      to,
      subject: '欢迎加入 MkSaaS',
      template: 'welcome',
      status: result.success ? 'sent' : 'failed',
      error: result.error,
      messageId: result.id,
    });
    
    return result;
  },
  
  // 发送密码重置邮件
  async sendPasswordResetEmail(to: string, resetUrl: string) {
    const html = render(PasswordResetEmail({ resetUrl }));
    
    return emailProvider.send({
      from: 'MkSaaS <noreply@mksaas.me>',
      to,
      subject: '重置密码',
      html,
    });
  },
  
  // 发送订单确认邮件
  async sendOrderConfirmation(to: string, orderDetails: OrderDetails) {
    const html = render(OrderConfirmationEmail(orderDetails));
    
    return emailProvider.send({
      from: 'MkSaaS <orders@mksaas.me>',
      to,
      subject: '订单确认',
      html,
    });
  },
  
  // 批量发送邮件
  async sendBulkEmails(emails: Email[]) {
    return emailProvider.sendBatch(emails);
  },
};
```

### 5. 邮件队列处理

```typescript
// src/lib/mail-queue.ts
import { Queue } from 'bullmq';
import { Redis } from 'ioredis';

const redis = new Redis(process.env.REDIS_URL!);

export const emailQueue = new Queue('emails', {
  connection: redis,
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 1000,
    },
  },
});

// 添加邮件到队列
export async function queueEmail(email: Email) {
  await emailQueue.add('send-email', email);
}

// Worker 处理邮件
import { Worker } from 'bullmq';

const emailWorker = new Worker(
  'emails',
  async (job) => {
    const email = job.data as Email;
    return mailService.send(email);
  },
  { connection: redis }
);

emailWorker.on('completed', (job) => {
  console.log(`Email ${job.id} sent successfully`);
});

emailWorker.on('failed', (job, err) => {
  console.error(`Email ${job?.id} failed:`, err);
});
```

## 五、环境配置

### 1. 存储配置

```env
# .env.local

# AWS S3
AWS_REGION=us-east-1
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
AWS_S3_BUCKET=mksaas-files

# 腾讯云 COS
COS_REGION=ap-guangzhou
COS_SECRET_ID=your-secret-id
COS_SECRET_KEY=your-secret-key
COS_BUCKET=mksaas-1234567890

# Cloudflare R2
R2_ACCOUNT_ID=your-account-id
R2_ACCESS_KEY_ID=your-access-key
R2_SECRET_ACCESS_KEY=your-secret-key
R2_BUCKET=mksaas-files

# 防盗链密钥
HOTLINK_SECRET=your-hotlink-secret
```

### 2. 邮件配置

```env
# Resend
RESEND_API_KEY=re_xxxxx

# Postmark
POSTMARK_API_KEY=xxxxx

# SMTP (备用)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASSWORD=your-password
```

## 六、最佳实践

### 1. 文件存储

- 使用 CDN 加速文件访问
- 实施多级缓存策略
- 定期清理过期文件
- 监控存储使用量

### 2. 防盗链

- 结合多种防盗链机制
- 设置合理的过期时间
- 记录访问日志
- 定期审查异常访问

### 3. 邮件发送

- 使用邮件队列处理
- 实施重试机制
- 记录发送日志
- 监控发送成功率

### 4. 安全性

- 验证用户权限
- 加密敏感数据
- 限制访问频率
- 实施审计日志

## 总结

MkSaaS 提供了完整的文件存储和邮件发送解决方案，包括多种云存储支持、完善的防盗链机制、灵活的邮件模板系统和可靠的队列处理。通过这些功能，可以构建安全、高效的文件管理和通知系统。
